<!DOCTYPE html>
<html>
<head>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <!-- Routing Machine JS -->
    <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>

    <title>Stations Vélo'v</title>

    <!-- Leaflet CSS -->
    <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet/dist/leaflet.css"
    />

    <!-- Routing Machine CSS -->
    <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css"
    />

    <link rel="stylesheet" href="style.css" />

    <meta charset="utf-8">
</head>



<body onload="initialize_page()">
    <h1>Stations Vélo'v</h1>

    <button id="toggle-route-form" class="toggle-button">
        <span class="toggle-icon">&#9776;</span> Itinéraire
    </button>

    <div id="map"></div>

    <!-- formulaire GPS -->
    <div id="route-panel" class="side-panel">
        <div class="panel-header">
            <h2>Calculer un itinéraire</h2>
            <button id="close-panel" class="close-button">&times;</button>
        </div>
        <form id="route-form">
            <div class="form-group">
                <label for="start-address">Adresse de départ</label>
                <input type="text" id="start-address" name="start" placeholder="Ex : 10 Rue de la République, Lyon" required>
            </div>
            <div class="form-group">
                <label for="end-address">Adresse d'arrivée</label>
                <input type="text" id="end-address" name="end" placeholder="Ex : 5 Place Bellecour, Lyon" required>
            </div>
            <button type="submit" class="submit-button">Calculer l'itinéraire</button>
            
            <img id="velo_margot" src="images/velo1.jpg">
            
        </form>
    </div>

        <script>
            // Gestion du bouton toggle pour afficher/masquer le formulaire
            document.getElementById('toggle-route-form').addEventListener('click', () => {
                const panel = document.getElementById('route-panel');
                panel.classList.toggle('visible');
            });

            // Gestion du bouton de fermeture du panneau
            document.getElementById('close-panel').addEventListener('click', () => {
                const panel = document.getElementById('route-panel');
                panel.classList.remove('visible');
            });
        </script>
</body>



<script>
    var map; // Déclarer la variable map globalement
    window.routeSegments = []; // Sert à stocker les routes GPS (éventuellemnt pour les enlever si on modifie le parcours)

    // Définition de markers colorées
    const redIcon = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
    });

    const greenIcon = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
    });

    const blueIcon = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
    });


    // Fonction de géocodage via Nominatim
    async function geocode(address) {
        const url = 'https://nominatim.openstreetmap.org/search'
                  + '?format=json'
                  + '&limit=1'
                  + `&q=${encodeURIComponent(address)}`;
        const res = await fetch(url, {
            headers: { 'Accept-Language': 'fr' }
        });
        const data = await res.json();
        if (!data.length) {
            throw new Error(`Adresse non trouvée : "${address}"`);
        }
        return [ parseFloat(data[0].lat), parseFloat(data[0].lon) ];
    }

    // Charger toutes les stations une seule fois
    let stations = [];
    async function loadStations() {
        const res = await fetch('/regions');
        if (!res.ok) throw new Error('Impossible de charger les stations');
        stations = await res.json();
    }
    loadStations();

    // Calcul de la distance (haversine)
    function haversine([lat1, lon1], [lat2, lon2]) {
        const R = 6371e3; // mètres
        const phi1 = lat1 * Math.PI/180;
        const phi2 = lat2 * Math.PI/180;
        const deltaPhi = (lat2-lat1) * Math.PI/180;
        const deltaLanda = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(deltaPhi/2)**2 + Math.cos(phi1)*Math.cos(phi2)*Math.sin(deltaLanda/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // Recherche de la station la plus proche
    function findNearest(coord) {
        let minDist = Infinity;
        let nearest = null;
        for (const s of stations) {
            const d = haversine(coord, [s.lat, s.lon]);
            if (d < minDist) {
                minDist = d;
                nearest = s;
            }
        }
        return nearest;
    }


    // Gestionnaire du formulaire
    document.getElementById('route-form').addEventListener('submit', async e => {
        e.preventDefault();
        const startAddr = document.getElementById('start-address').value.trim();
        const endAddr   = document.getElementById('end-address').value.trim();

        try {
            // géocodage en parallèle
            const [startCoord, endCoord] = await Promise.all([
                geocode(startAddr),
                geocode(endAddr)
        ]);

        // Marker adresses
        L.marker(startCoord, { icon: greenIcon }).addTo(map).bindPopup('Vous êtes ici').openPopup();
        L.marker(endCoord,   { icon: redIcon   }).addTo(map).bindPopup('Arrivée prévue');

        // Station la plus proche de chaque extrémité
        const stStart = findNearest(startCoord);
        const stEnd   = findNearest(endCoord);

        // Supprime les marqueurs de ces stations préexistants
        map.eachLayer(layer => {
            if (layer instanceof L.Marker && (layer.stationId === stStart.idstation || layer.stationId === stEnd.idstation)) {
                map.removeLayer(layer);
            }
        });

        // Ajoute les nouveaux marqueurs bleu avec popup buildée
        [ {info: stStart, label: 'Station de départ'}, {info: stEnd, label: 'Station d’arrivée'} ]
        .forEach(({info, label}) => {
            const m = L.marker([info.lat, info.lon], { icon: blueIcon }).addTo(map);
            fetch('/station/' + info.idstation)
                .then(res => res.json())
                .then(station => m.bindPopup(buildStationPopupContent(station, label)).openPopup())
                .catch(err => console.error(err));
        });

        
        //Section servant à tracer les routes GPS

        // Supression des anciens tracés s'il y en a
        window.routeSegments.forEach(line => map.removeLayer(line));
        window.routeSegments.length = 0;

        // Instancie le routeur OSRM
        const router = L.Routing.osrmv1({
            serviceUrl: 'https://router.project-osrm.org/route/v1'
        });

        //Création de trois segments (départ - station / station de départ - station arrivée / station arrivée - arrivée)
        const segments = [
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(startCoord)),
                    L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon))
                ],
                color: 'green'
            },
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon)),
                    L.Routing.waypoint(L.latLng(stEnd.lat,   stEnd.lon))
                ],
                color: 'blue'
            },
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(stEnd.lat,   stEnd.lon)),
                    L.Routing.waypoint(L.latLng(endCoord))
                ],
                color: 'red'
            }
        ];

        // Pour chaque segment, appelle le routeur, trace la ligne, et mémorise
        segments.forEach(({ waypoints, color }) => {
            router.route(waypoints, (err, routes) => {
                if (err || !routes.length) {
                    return console.error('Erreur routage', err);
                }
                const line = L.Routing.line(routes[0], {
                    styles: [{ color, weight: 4, opacity: 0.8 }]
                }).addTo(map);
                window.routeSegments.push(line);
            });
        });

        // On recadre la carte sur l’intégralité du trajet
        const bounds = L.latLngBounds([
            startCoord,
            [stStart.lat, stStart.lon],
            [stEnd.lat,   stEnd.lon],
            endCoord
        ]);
        map.fitBounds(bounds, { padding: [50, 50] });



        } catch (err) {
            alert(err.message);
            console.error(err);
        };
    });



    // Fonction d'initialisation de la page
    function initialize_page() {
        // Initialiser la carte avec un centre temporaire
        map = L.map('map').setView([45.75, 4.85], 13);
        
        // Ajouter les tuiles OpenStreetMap
        L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        
        // Charger le centre de la carte puis les données
        initialize_map();
        load_data();
    }
    
    // Récupérer le centre géographique des stations et centrer la carte
    function initialize_map() {
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
            if (this.status != 200) {
                console.error("Erreur lors de la récupération du centre des stations");
                return;
            }
            var center = JSON.parse(this.responseText);
            // Centrer la carte sur le centre calculé
            map.setView([center.lat, center.lon], 14);
        };
        xhr.open('GET', '/center', true);
        xhr.send();
    }


    // charger les marqueurs avec leurs IDs
    function load_data () {
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
          if (this.status != 200) {
            console.error("Erreur lors de la récupération des stations");
            return;
          }
          
          // Définir une icône personnalisée avec taille spécifique
          var customIcon = L.icon({
              iconUrl: 'images/marker-icon_v.png',
              iconSize: [45, 45],
              iconAnchor: [0, 0],
              popupAnchor: [22, 0]
          });
          
          var data = JSON.parse(this.responseText);
          for (n = 0; n < data.length; n++) {
            // Ajouter l'ID de la station pour pouvoir le récupérer lors du clic
            L.marker([data[n].lat, data[n].lon], {icon: customIcon}).addTo(map)
              .bindPopup(data[n].nom)
              .addEventListener('click', OnMarkerClick)
              .stationId = data[n].idstation || data[n].nom; // Utiliser idstation s'il existe, sinon nom
          }
        };
        xhr.open('GET', '/regions', true);
        xhr.send();
    }
    
    // Construit le HTML complet d’une popup de station.
    // @param {Object} station  Objet tel que renvoyé par /station/{id}
    // @param {string} [label]  Texte à préfixer au nom (ex. « Station de départ »)
    // @returns {string} HTML
    function buildStationPopupContent(station, label = station.nom) {
        // Construction du HTML pour la popup
        var content = '<div class="station-popup">';
          
        // En-tête avec nom et statut
        content += '<h3>' + station.nom + '</h3>';
        content += '<div class="address">' + formatAddress(station) + '</div>';

        // Statut de la station (ouverte/fermée)
        var statusClass = station.status === 'OPEN' ? 'status-open' : 'status-closed';
        var statusText = station.status === 'OPEN' ? 'Ouverte' : 'Fermée';
        content += '<div class="info-row"><span class="label">Statut :</span> <span class="value ' + statusClass + '">' + statusText + '</span></div>';

        // Capacité totale
        content += '<div class="info-row"><span class="label">Capacité :</span> <span class="value">' + station.capacity + ' bornettes</span></div>';

        // Places disponibles et vélos disponibles
        content += '<div class="info-row"><span class="label">Places libres :</span> <span class="value">' + station.stands + '</span></div>';
        content += '<div class="info-row"><span class="label">Vélos disponibles :</span> <span class="value">' + station.bikes + '</span></div>';

        // Types de vélos disponibles
        content += '<div class="bikes-available">';
        content += '<div class="bike-type"><div class="bike-count">' + station.electricalBikes + '</div><div>Électriques</div></div>';
        content += '<div class="bike-type"><div class="bike-count">' + station.mechanicalBikes + '</div><div>Mécaniques</div></div>';
        content += '</div>';

        // Information bonus
        if (station.stationbonus === 'oui') {
        content += '<div class="info-row"><span class="label">Station bonus</span> <span class="value">✓</span></div>';
        }

        // Dernière mise à jour
        content += '<div class="last-update">Dernière mise à jour : ' + formatDate(station.horodate) + '</div>';
        content += '</div>';


        content += `
            <div style="margin-top: 0.5em;">
              <div>
                Début : 
                <input type="range" id="startRange-${station.idstation}" style="width:45%;">
                <span id="startLabel-${station.idstation}"></span>
              </div>
              <div style="margin-top:0.3em;">
                Fin :   
                <input type="range" id="endRange-${station.idstation}"   style="width:45%;">
                <span id="endLabel-${station.idstation}"></span>
              </div>
              <div style="margin-top:0.5em;">
                <button onclick="loadHistoryImg(${station.idstation})">
                  Afficher la courbe
                </button>
              </div>
              <div style="margin-top:0.5em;">
                <img id="img-${station.idstation}" style="display:block; width:100%;" />
              </div>
            </div>
          `;

        return content;
    }


    function OnMarkerClick(e) {
        const id = e.target.stationId;
        fetch('/station/' + id)
            .then(res => res.json())
            .then(station => {
              const popup = e.target.getPopup();
              popup.setContent(buildStationPopupContent(station))
                   .update();
              initRanges(id);
            })
            .catch(err => console.error(err));
    }

    // Fonction pour formater l'adresse
    function formatAddress(station) {
        let address = station.adresse1 || '';
        if (station.adresse2 && station.adresse2.trim() !== '') {
            address += ', ' + station.adresse2;
        }
        if (station.commune) {
            address += ' - ' + station.commune;
        }
        return address;
    }

    // Fonction pour formater la date
    function formatDate(dateStr) {
        if (!dateStr) return 'Non disponible';
        try {
            const date = new Date(dateStr);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        } catch (e) {
            return dateStr;
        }
    }


    /**
     * Initialise deux input[type=range] pour choisir la plage [minTs…maxTs]
     * et affiche leur valeur dans les <span>.
     */
    function initRanges(id) {
      const minTs = Date.parse('2024-10-25T00:00:00');
      const maxTs = Date.parse('2024-10-29T23:59:59');
      const sr = document.getElementById('startRange-'+id);
      const er = document.getElementById('endRange-'+id);
      const sl = document.getElementById('startLabel-'+id);
      const el = document.getElementById('endLabel-'+id);

      // config des sliders
      [sr, er].forEach(inp => {
        inp.min   = minTs;
        inp.max   = maxTs;
        inp.step  = 60 * 1000;    // pas de 1 minute
      });
      sr.value = minTs;
      er.value = maxTs;

      // mettre à jour l’affichage
      function updateLabels() {
        sl.textContent = new Date(+sr.value).toLocaleString('fr-FR');
        el.textContent = new Date(+er.value).toLocaleString('fr-FR');
      }
      sr.addEventListener('input', updateLabels);
      er.addEventListener('input', updateLabels);
      updateLabels();
    }

    /**
     * Lit les valeurs des deux ranges, formate en "YYYY-MM-DD HH:MM:SS"
     * et recharge l'<img> avec la nouvelle URL.
     */
    function loadHistoryImg(id) {
      const sr = document.getElementById('startRange-'+id);
      const er = document.getElementById('endRange-'+id);

      const fmt = ts => new Date(+ts)
        .toISOString().slice(0,19).replace('T',' ');

      const params = new URLSearchParams({
        start: fmt(sr.value),
        end:   fmt(er.value)
      });

      document.getElementById('img-'+id)
              .src = `/history_png/${id}?${params.toString()}`;
    }

    // Gestion de l'affichage du panneau d'itinéraire
    document.addEventListener('DOMContentLoaded', function() {
        const toggleButton = document.getElementById('toggle-route-form');
        const closeButton = document.getElementById('close-panel');
        const routePanel = document.getElementById('route-panel');
        
        // Afficher le panneau quand on clique sur le bouton
        toggleButton.addEventListener('click', function() {
            routePanel.classList.add('active');
        });
        
        // Fermer le panneau quand on clique sur le bouton de fermeture
        closeButton.addEventListener('click', function() {
            routePanel.classList.remove('active');
        });
        
        // Fermer le panneau quand on clique en dehors
        document.addEventListener('click', function(event) {
            if (!routePanel.contains(event.target) && 
                !toggleButton.contains(event.target) && 
                routePanel.classList.contains('active')) {
                routePanel.classList.remove('active');
            }
        });
    });

</script>