<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
    <title>Stations Vélo'v</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
    <link rel="stylesheet" href="style.css" />
    <meta charset="utf-8">
</head>

<body onload="initialize_page()">
    <header>
        <nav class="top-controls">
            <div id="filters">
                <button onclick="showStations('all')">Toutes</button>
                <button onclick="showStations('electric')"><img src="images/lightning.png" alt="Vélos électriques"></button>
                <button onclick="showStations('mechanical')"><img src="images/jambe.png" alt="Vélos mécaniques"></button>
                <button onclick="showStations('empty')"><img src="images/empty.png" alt="Stations vides" style="height:20px;"></button>
                <button onclick="showStations('closed')"><img src="images/closed.png" alt="Stations fermées" style="height:20px;"></button>
            </div>
            <h1>Stations Vélo'v</h1>
            <button id="toggle-route-form" class="toggle-button">
                <span class="toggle-icon">&#9776;</span> Itinéraire
            </button>
        </nav>
    </header>

    <div id="map"></div>

    <div id="route-panel" class="side-panel">
        <div class="panel-header">
            <h2>Calculer un itinéraire</h2>
            <button id="close-panel" class="close-button">&times;</button>
        </div>
        <form id="route-form">
            <div class="form-group">
                <label for="start-address">Adresse de départ</label>                
                    <input type="text" id="start-address" name="start" placeholder="Ex : 10 Rue de la République, Lyon" required>
                <button type="button" id="select-start-button" class="map-select-button">Sélectionner sur la carte</button>
            </div>
            <div class="form-group">
                <label for="end-address">Adresse d'arrivée</label>                
                    <input type="text" id="end-address" name="end" placeholder="Ex : 5 Place Bellecour, Lyon" required>
                <button type="button" id="select-end-button" class="map-select-button">Sélectionner sur la carte</button>
            </div>
            <div class="form-group">
                <label for="bike-type">Type de vélo :</label>
                <select id="bike-type" name="bike-type">
                    <option value="any">Peu importe</option>
                    <option value="mechanical">Mécanique</option>
                    <option value="electric">Électrique</option>
                </select>
            </div>
            <button type="button" id="reset-route-button" class="reset-button">Réinitialiser</button>
            <button type="button" id="calculate-route-button" class="submit-button">Calculer l'itinéraire</button>
            <img id="velo_margot" src="images/velo1.jpg">
        </form>
    </div>

    <div id="graph-panel" class="bottom-panel">
        <div class="panel-header">
            <h2>Évolution de la station</h2>
            <button id="close-graph-panel" class="close-button">&times;</button>
        </div>
        <div class="panel-content">
            <div id="graph-station-info"></div>
            <div id="graph-date-info" class="date-info"></div>
            
            <div class="graph-image-container">
                <img id="graph-image" alt="Graphique d'occupation" style="width:100%; height:auto;">
            </div>
            
            <div class="graph-options">
                <h4>Données à afficher :</h4>
                <div class="graph-options-checkboxes">
                    <label><input type="checkbox" id="show-total" checked> Vélos totaux</label>
                    <label><input type="checkbox" id="show-stands" checked> Places libres</label>
                    <label><input type="checkbox" id="show-mechanical" checked> Vélos mécaniques</label>
                    <label><input type="checkbox" id="show-electric" checked> Vélos électriques</label>
                </div>
                <button id="update-graph" class="update-button">Mettre à jour le graphique</button>
            </div>
        </div>
    </div>
</body>

<script>
    // Variables globales
    let startMarker = null;
    let endMarker = null;
    let selectionMode = null;
    let selectionNotification = null;
    let map;
    let stations = [];
    let maxBikesCount = 0;
    let maxElectricCount = 0;
    let maxMechanicalCount = 0;
    let currentDisplayMode = 'all';
    window.routeSegments = [];
    window.stationMarkers = [];

    // Icônes
    const redIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });

    const greenIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });

    const blueIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });

    // Initialisation de la page
    function initialize_page() {
        map = L.map('map').setView([45.75, 4.85], 13);
        
        L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        
        map.on('click', handleMapClick);
        
        fetch('/center')
            .then(response => response.json())
            .then(center => map.setView([center.lat, center.lon], 14))
            .catch(err => console.error("Erreur chargement du centre:", err));
        
        loadStations();
        setupEventListeners();
    }

    // Chargement des stations
    function loadStations() {
        fetch('/stations_full')
            .then(response => response.json())
            .then(data => {
                stations = data;
                window.stations = data;
                
                // Calculer les maximums
                maxBikesCount = Math.max(...data.map(s => s.bikes || 0));
                maxElectricCount = Math.max(...data.map(s => s.electricalBikes || 0));
                maxMechanicalCount = Math.max(...data.map(s => s.mechanicalBikes || 0));
                
                // Créer les marqueurs
                data.forEach(station => {
                    const marker = L.marker([station.lat, station.lon], {
                        icon: getStationIcon(station, 'all')
                    });
                    
                    marker.stationData = station;
                    marker.stationId = station.idstation;
                    marker.on('click', function(e) {
                        const popup = buildStationPopupContent(e.target.stationData);
                        e.target.unbindPopup().bindPopup(popup).openPopup();
                        initRanges(e.target.stationData.idstation);
                    });
                    
                    window.stationMarkers.push({marker, data: station});
                });
                
                showStations('all');
            })
            .catch(err => console.error("Erreur chargement des stations:", err));
    }

    // Gestion de la sélection de points sur la carte
    function activateSelectionMode(mode) {
        deactivateSelectionMode();
        selectionMode = mode;
        document.getElementById('map').classList.add('selecting-point');
        
        const message = mode === 'start' 
            ? 'Cliquez sur la carte pour sélectionner un point de départ'
            : 'Cliquez sur la carte pour sélectionner un point d\'arrivée';
        
        selectionNotification = document.createElement('div');
        selectionNotification.className = 'selection-notification';
        selectionNotification.textContent = message;
        document.body.appendChild(selectionNotification);
    }

    function deactivateSelectionMode() {
        selectionMode = null;
        document.getElementById('map').classList.remove('selecting-point');
        if (selectionNotification) {
            selectionNotification.remove();
            selectionNotification = null;
        }
    }

    function handleMapClick(e) {
        if (!selectionMode) return;
        
        const latlng = e.latlng;
        
        if (selectionMode === 'start') {
            if (startMarker) map.removeLayer(startMarker);
            
            startMarker = L.marker(latlng, {
                icon: greenIcon,
                draggable: true
            }).addTo(map);
            
              startMarker.on('dragend', function() {
                const newPos = startMarker.getLatLng();
                storeCoordinates('start-address', newPos);
                reverseGeocode(newPos, 'start-address');
            });
            
            storeCoordinates('start-address', latlng);
            reverseGeocode(latlng, 'start-address');
        } 
        else if (selectionMode === 'end') {
            if (endMarker) map.removeLayer(endMarker);
            
            endMarker = L.marker(latlng, {
                icon: redIcon,
                draggable: true
            }).addTo(map);
            
            endMarker.on('dragend', function() {
                const newPos = endMarker.getLatLng();
                storeCoordinates('end-address', newPos);
                reverseGeocode(newPos, 'end-address');
            });
            
            storeCoordinates('end-address', latlng);
            reverseGeocode(latlng, 'end-address');
        }
        
        deactivateSelectionMode();
    }    function storeCoordinates(inputId, latlng) {
        const inputElement = document.getElementById(inputId);
        inputElement.dataset.exactLat = latlng.lat;
        inputElement.dataset.exactLng = latlng.lng || latlng.lon;
        inputElement.dataset.hasExactCoordinates = "true";
    }

    // Calcul d'itinéraire
    function calculateItinerary(e) {
        if (e) e.preventDefault();
        
        const startInput = document.getElementById('start-address');
        const endInput = document.getElementById('end-address');
        const startAddress = startInput.value;
        const endAddress = endInput.value;
        
        if (!startAddress || !endAddress) {
            alert("Veuillez spécifier une adresse de départ et d'arrivée.");
            return;
        }
        
        if (startInput.dataset.hasExactCoordinates === "true" && 
            endInput.dataset.hasExactCoordinates === "true" && 
            startMarker && endMarker) {
            calculateRouteFromMarkers();
        } else {
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
                startInput.removeAttribute('data-has-exact-coordinates');
                document.getElementById('reset-start-button').style.display = 'none';
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
                endInput.removeAttribute('data-has-exact-coordinates');
                document.getElementById('reset-end-button').style.display = 'none';
            }
            calculateRoute(startAddress, endAddress);
        }
    }

    function calculateRouteFromMarkers() {
        if (!startMarker || !endMarker) return;
        
        const startPos = startMarker.getLatLng();
        const endPos = endMarker.getLatLng();
        
        // Nettoyage des routes précédentes
        clearRoutes();
        
        // Stations les plus proches
        const startCoord = [startPos.lat, startPos.lng];
        const endCoord = [endPos.lat, endPos.lng];
        const stStart = findNearest(startCoord, true); // Station de départ avec vélos disponibles
        const stEnd = findNearest(endCoord, false);    // Station d'arrivée
        
        // Vérifier si la station de départ a été trouvée
        if (stStart.idstation === "none") {
            alert(stStart.nom);
            return;
        }
        
        // Calcul des itinéraires
        const router = L.Routing.osrmv1({
            serviceUrl: 'https://router.project-osrm.org/route/v1',
            profile: 'cycling',
            language: 'fr'
        });
        
        const segments = [
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(startPos.lat, startPos.lng)),
                    L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon))
                ],
                color: 'green'
            },
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon)),
                    L.Routing.waypoint(L.latLng(stEnd.lat, stEnd.lon))
                ],
                color: 'blue'
            },
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(stEnd.lat, stEnd.lon)),
                    L.Routing.waypoint(L.latLng(endPos.lat, endPos.lng))
                ],
                color: 'red'
            }
        ];
        
        segments.forEach(({waypoints, color}) => {
            router.route(waypoints, (err, routes) => {
                if (err || !routes.length) return console.error('Erreur routage', err);
                
                const line = L.Routing.line(routes[0], {
                    styles: [{color, weight: 4, opacity: 0.8}]
                }).addTo(map);
                
                window.routeSegments.push(line);
            });
        });
        
        // Ajuster la vue
        const bounds = L.latLngBounds([
            [startPos.lat, startPos.lng],
            [stStart.lat, stStart.lon],
            [stEnd.lat, stEnd.lon],
            [endPos.lat, endPos.lng]
        ]);
        map.fitBounds(bounds, {padding: [50, 50]});
    }

    async function calculateRoute(startAddress, endAddress) {
        try {
            clearRoutes();
            
            // Géocodage en parallèle
            const [startCoord, endCoord] = await Promise.all([
                geocode(startAddress),
                geocode(endAddress)
            ]);            // Stations les plus proches
            const stStart = findNearest(startCoord, true); // Station de départ avec vélos disponibles
            const stEnd = findNearest(endCoord, false);    // Station d'arrivée

            // Vérifier si la station de départ a été trouvée
            if (stStart.idstation === "none") {
                alert(stStart.nom);
                return;
            }

            // Supprime les marqueurs de ces stations préexistants
            map.eachLayer(layer => {
                if (layer instanceof L.Marker && (layer.stationId === stStart.idstation || layer.stationId === stEnd.idstation)) {
                    map.removeLayer(layer);
                }
            });
            
            // Ajoute les nouveaux marqueurs bleu avec popup buildée
            [ {info: stStart, label: 'Station de départ'}, {info: stEnd, label: 'Station d\'arrivée'} ].forEach(({info, label}) => {
                const m = L.marker([info.lat, info.lon], { icon: blueIcon }).addTo(map);
                m.stationId = info.idstation; // Stocker l'ID pour pouvoir retrouver ce marqueur plus tard
                fetch('/station/' + info.idstation)
                    .then(res => res.json())
                    .then(station => m.bindPopup(buildStationPopupContent(station, label)).openPopup())
                    .catch(err => console.error(err));
            });
            
            // Calcul des itinéraires
            const router = L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'cycling',
                language: 'fr'
            });
            
            const segments = [
                {
                    waypoints: [
                        L.Routing.waypoint(L.latLng(startCoord)),
                        L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon))
                    ],
                    color: 'green'
                },
                {
                    waypoints: [
                        L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon)),
                        L.Routing.waypoint(L.latLng(stEnd.lat, stEnd.lon))
                    ],
                    color: 'blue'
                },
                {
                    waypoints: [
                        L.Routing.waypoint(L.latLng(stEnd.lat, stEnd.lon)),
                        L.Routing.waypoint(L.latLng(endCoord))
                    ],
                    color: 'red'
                }
            ];
            
            segments.forEach(({waypoints, color}) => {
                router.route(waypoints, (err, routes) => {
                    if (err || !routes.length) return console.error('Erreur routage', err);
                    
                    const line = L.Routing.line(routes[0], {
                        styles: [{color, weight: 4, opacity: 0.8}]
                    }).addTo(map);
                    
                    window.routeSegments.push(line);
                });
            });
            
            // Ajuster la vue
            const bounds = L.latLngBounds([
                startCoord,
                [stStart.lat, stStart.lon],
                [stEnd.lat, stEnd.lon],
                endCoord
            ]);
            map.fitBounds(bounds, {padding: [50, 50]});
        } catch (error) {
            alert(error.message || "Erreur lors du calcul de l'itinéraire");
            console.error("Erreur:", error);
        }
    }

    function clearRoutes() {
        // Supprimer les tracés existants
        if (window.routingControl) {
            map.removeControl(window.routingControl);
            window.routingControl = null;
        }
        
        window.routeSegments.forEach(line => map.removeLayer(line));
        window.routeSegments.length = 0;
        
        // Supprimer les marqueurs d'itinéraire (sauf start/end)
        map.eachLayer(layer => {
            if (layer instanceof L.Marker && layer !== startMarker && layer !== endMarker) {
                if (layer._icon && layer._icon.src && 
                   (layer._icon.src.includes('red.png') || 
                    layer._icon.src.includes('green.png') || 
                    layer._icon.src.includes('blue.png'))) {
                    map.removeLayer(layer);
                }
            }
        });
    }

    // Géocodage et recherche de proximité
    async function reverseGeocode(latlng, inputId) {
        try {
            const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&addressdetails=1&zoom=18`;
            const response = await fetch(url, {
                headers: {'Accept-Language': 'fr'}
            });
            
            if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
            
            const data = await response.json();
            
            let address = '';
            const addr = data.address;
            
            if (addr.house_number) address += addr.house_number + ', ';
            if (addr.road) address += addr.road;
            if (addr.city || addr.town || addr.village) {
                address += ' - ' + (addr.city || addr.town || addr.village);
            }
            
            if (!address) address = data.display_name;
            
            document.getElementById(inputId).value = address;
        } catch (error) {
            console.error('Erreur géocodage inverse:', error);
        }
    }    async function geocode(address) {
        try {
            // Vérifier si on a des coordonnées exactes pour cette adresse
            const inputElement = document.querySelector(`input[value="${address}"]`) || 
                                (document.getElementById('start-address').value === address ? document.getElementById('start-address') : 
                                 document.getElementById('end-address').value === address ? document.getElementById('end-address') : null);
            
            if (inputElement && inputElement.dataset.hasExactCoordinates === "true") {
                return [parseFloat(inputElement.dataset.exactLat), parseFloat(inputElement.dataset.exactLng)];
            }
            
            if (inputElement && inputElement.dataset.lat && inputElement.dataset.lon) {
                return [parseFloat(inputElement.dataset.lat), parseFloat(inputElement.dataset.lon)];
            }

            // Vérifier si l'entrée est des coordonnées GPS (formats acceptés: "45.75, 4.85" ou "45.75 4.85")
            const gpsRegex = /^(-?\d+(\.\d+)?)\s*[,\s]\s*(-?\d+(\.\d+)?)$/;
            const gpsMatch = address.match(gpsRegex);
            
            if (gpsMatch) {
                const lat = parseFloat(gpsMatch[1]);
                const lon = parseFloat(gpsMatch[3]);
                
                // Vérifier que les coordonnées sont valides
                if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                    console.log(`Coordonnées GPS détectées: ${lat}, ${lon}`);
                    return [lat, lon];
                }
            }
            
            // Géocodage via API
            const url = 'https://nominatim.openstreetmap.org/search'
                    + '?format=json&limit=1&countrycodes=fr'
                    + '&viewbox=4.7,45.6,5.0,45.9&bounded=1'
                    + `&q=${encodeURIComponent(address)}`;
                    
            const res = await fetch(url, {
                headers: {'Accept-Language': 'fr'}
            });
            
            if (!res.ok) throw new Error(`Erreur géocodage: ${res.status}`);
            
            const data = await res.json();
            if (!data.length) throw new Error(`Adresse non trouvée: "${address}"`);
            
            return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        } catch (error) {
            throw new Error(`Impossible de localiser: "${address}"`);
        }
    }

    function haversine([lat1, lon1], [lat2, lon2]) {
        const R = 6371e3; // mètres
        const phi1 = lat1 * Math.PI/180;
        const phi2 = lat2 * Math.PI/180;
        const deltaPhi = (lat2-lat1) * Math.PI/180;
        const deltaLanda = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(deltaPhi/2)**2 + Math.cos(phi1)*Math.cos(phi2)*Math.sin(deltaLanda/2)**2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }    function findNearest(coord, isStartStation = false) {
        if (!stations || stations.length === 0) {
            return {idstation: "none", nom: "Aucune station disponible", lat: coord[0], lon: coord[1]};
        }
        
        let minDist = Infinity;
        let nearest = null;
        
        // Pour la station de départ, on doit vérifier la disponibilité des vélos
        const bikeType = document.getElementById('bike-type').value;
        
        for (const s of stations) {
            if (!s.lat || !s.lon) continue;
            
            // Si c'est la station de départ, vérifier la disponibilité des vélos selon le type
            if (isStartStation) {
                // Station fermée, on passe
                if (s.status !== 'OPEN') continue;
                
                // Vérifier si la station a des vélos du type demandé
                if (bikeType === 'electric' && (!s.electricalBikes || s.electricalBikes <= 0)) continue;
                if (bikeType === 'mechanical' && (!s.mechanicalBikes || s.mechanicalBikes <= 0)) continue;
                if (bikeType === 'any' && (!s.bikes || s.bikes <= 0)) continue;
            }
            
            const d = haversine(coord, [s.lat, s.lon]);
            if (d < minDist) {
                minDist = d;
                nearest = s;
            }
        }
        
        if (!nearest) {
            if (isStartStation) {
                let errorMsg = "Aucune station disponible avec ";
                if (bikeType === 'electric') errorMsg += "des vélos électriques";
                else if (bikeType === 'mechanical') errorMsg += "des vélos mécaniques";
                else errorMsg += "des vélos";
                errorMsg += " à proximité";
                
                return {idstation: "none", nom: errorMsg, lat: coord[0], lon: coord[1]};
            } else {
                return {idstation: "none", nom: "Aucune station à proximité", lat: coord[0], lon: coord[1]};
            }
        }
        
        return nearest;
    }

    // Gestion des marqueurs de stations
    function getStationIcon(station, mode) {
        const isClosed = station.status !== 'OPEN';
        const electricCount = station.electricalBikes || 0;
        const mechanicalCount = station.mechanicalBikes || 0;
        const totalBikes = electricCount + mechanicalCount;
        const isEmpty = totalBikes === 0;
        
        // Taille de l'icône basée sur le nombre de vélos
        const minSize = 30, maxSize = 60;
        let size = minSize;
        
        if (mode === 'all' && !isEmpty && !isClosed) {
            const ratio = totalBikes / maxBikesCount;
            size = minSize + (maxSize - minSize) * ratio;
        } else if (mode === 'electric' && electricCount > 0 && !isClosed) {
            const ratio = electricCount / maxElectricCount;
            size = minSize + (maxSize - minSize) * ratio;
        } else if (mode === 'mechanical' && mechanicalCount > 0 && !isClosed) {
            const ratio = mechanicalCount / maxMechanicalCount;
            size = minSize + (maxSize - minSize) * ratio;
        }
        
        let iconUrl;
        
        // Choisir l'icône selon le type de station
        if (isClosed) {
            iconUrl = 'images/marker-icon_v_closed.png';
        } else if (isEmpty) {
            iconUrl = 'images/marker-icon_v_empty.png';
        } else if (mode === 'electric' && electricCount > 0) {
            iconUrl = 'images/marker-icon_v_elec.png';
        } else if (mode === 'mechanical' && mechanicalCount > 0) {
            iconUrl = 'images/marker-icon_v_meca.png';
        } else if (electricCount > 0 && mechanicalCount > 0) {
            // Icône mixte pour stations avec les deux types de vélos
            return createMixedIcon(station, size, electricCount / totalBikes);
        } else if (electricCount > 0) {
            iconUrl = 'images/marker-icon_v_elec.png';
        } else {
            iconUrl = 'images/marker-icon_v_meca.png';
        }
        
        return L.icon({
            iconUrl: iconUrl,
            iconSize: [size, size],
            iconAnchor: [size/2, size],
            popupAnchor: [0, -size]
        });
    }

    function createMixedIcon(station, size, electricRatio) {
        const container = document.createElement('div');
        container.style.position = 'relative';
        container.style.width = `${size}px`;
        container.style.height = `${size}px`;
        
        // Élément pour vélos mécaniques (arrière-plan)
        const mechDiv = document.createElement('div');
        mechDiv.style.position = 'absolute';
        mechDiv.style.top = '0';
        mechDiv.style.left = '0';
        mechDiv.style.width = `${size}px`;
        mechDiv.style.height = `${size}px`;
        mechDiv.style.backgroundImage = 'url(images/marker-icon_v_meca.png)';
        mechDiv.style.backgroundSize = 'cover';
        
        // Élément pour vélos électriques (partie proportionnelle)
        const elecDiv = document.createElement('div');
        elecDiv.style.position = 'absolute';
        elecDiv.style.top = '0';
        elecDiv.style.left = '0';
        elecDiv.style.width = Math.round(size * electricRatio) + 'px';
        elecDiv.style.height = `${size}px`;
        elecDiv.style.backgroundImage = 'url(images/marker-icon_v_elec.png)';
        elecDiv.style.backgroundSize = 'cover';
        elecDiv.style.overflow = 'hidden';
        
        container.appendChild(mechDiv);
        container.appendChild(elecDiv);
        
        return L.divIcon({
            html: container,
            className: 'custom-div-icon',
            iconSize: [size, size],
            iconAnchor: [size/2, size],
            popupAnchor: [0, -size]
        });
    }

    function showStations(mode) {
        currentDisplayMode = mode;
        
        // Supprimer tous les marqueurs existants
        map.eachLayer(function(layer) {
            if (layer instanceof L.Marker && layer !== startMarker && layer !== endMarker) {
                map.removeLayer(layer);
            }
        });
        
        // Afficher les marqueurs selon le mode
        window.stationMarkers.forEach(({marker, data}) => {
            const electricCount = data.electricalBikes || 0;
            const mechanicalCount = data.mechanicalBikes || 0;
            const totalBikes = electricCount + mechanicalCount;
            const isEmpty = totalBikes === 0;
            const isClosed = data.status !== 'OPEN';
            
            let shouldShow = true;
            
            switch(mode) {
                case 'empty': shouldShow = isEmpty && !isClosed; break;
                case 'closed': shouldShow = isClosed; break;
                case 'electric': shouldShow = electricCount > 0 || isClosed || isEmpty; break;
                case 'mechanical': shouldShow = mechanicalCount > 0 || isClosed || isEmpty; break;
            }
            
            if (shouldShow) {
                marker.setIcon(getStationIcon(data, mode));
                marker.addTo(map);
            }
        });
    }

    // Affichage des popups et graphiques
    function buildStationPopupContent(station, label = station.nom) {
        let content = '<div class="station-popup">';
        
        content += '<h3>' + label + '</h3>';
        content += '<div class="address">' + formatAddress(station) + '</div>';

        const statusClass = station.status === 'OPEN' ? 'status-open' : 'status-closed';
        const statusText = station.status === 'OPEN' ? 'Ouverte' : 'Fermée';
        content += '<div class="info-row"><span class="label">Statut :</span> <span class="value ' + statusClass + '">' + statusText + '</span></div>';
        content += '<div class="info-row"><span class="label">Capacité :</span> <span class="value">' + station.capacity + ' bornettes</span></div>';
        content += '<div class="info-row"><span class="label">Places libres :</span> <span class="value">' + station.stands + '</span></div>';
        content += '<div class="info-row"><span class="label">Vélos disponibles :</span> <span class="value">' + station.bikes + '</span></div>';

        content += '<div class="bikes-available">';
        content += '<div class="bike-type"><div class="bike-count">' + station.electricalBikes + '</div><div>Électriques</div></div>';
        content += '<div class="bike-type"><div class="bike-count">' + station.mechanicalBikes + '</div><div>Mécaniques</div></div>';
        content += '</div>';

        if (station.stationbonus === 'oui') {
            content += '<div class="info-row"><span class="label">Station bonus</span> <span class="value">✓</span></div>';
        }

        content += '<div class="last-update">Dernière mise à jour : ' + formatDate(station.horodate) + '</div>';

        content += `
            <div class="date-selector">
                <div class="date-group">
                    <label>Du:</label>
                    <div class="date-inputs">
                        <select id="startDay-${station.idstation}" class="date-select"></select>
                        <select id="startHour-${station.idstation}" class="time-select"></select>
                    </div>
                </div>
                <div class="date-group">
                    <label>Au:</label>
                    <div class="date-inputs">
                        <select id="endDay-${station.idstation}" class="date-select"></select>
                        <select id="endHour-${station.idstation}" class="time-select"></select>
                    </div>
                </div>
                <button class="graph-button" onclick="loadHistoryImg(${station.idstation})">
                    Afficher l'historique
                </button>
            </div>
        `;

        content += '</div>';
        return content;
    }

    function formatAddress(station) {
        let address = station.adresse1 || '';
        if (station.adresse2 && station.adresse2.trim() !== '') {
            address += ', ' + station.adresse2;
        }
        if (station.commune) {
            address += ' - ' + station.commune;
        }
        return address;
    }

    function formatDate(dateStr) {
        if (!dateStr) return 'Non disponible';
        try {
            const date = new Date(dateStr);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        } catch (e) {
            return dateStr;
        }
    }

    function initRanges(id) {
        const startDaySelect = document.getElementById(`startDay-${id}`);
        const endDaySelect = document.getElementById(`endDay-${id}`);
        const startHourSelect = document.getElementById(`startHour-${id}`);
        const endHourSelect = document.getElementById(`endHour-${id}`);
        
        // Vider les sélecteurs existants
        while (startDaySelect.firstChild) startDaySelect.removeChild(startDaySelect.firstChild);
        while (endDaySelect.firstChild) endDaySelect.removeChild(endDaySelect.firstChild);
        while (startHourSelect.firstChild) startHourSelect.removeChild(startHourSelect.firstChild);
        while (endHourSelect.firstChild) endHourSelect.removeChild(endHourSelect.firstChild);
        
        // Ajouter les dates disponibles (25-29 octobre au lieu de 24-28)
        const dates = ['2024-10-25', '2024-10-26', '2024-10-27', '2024-10-28', '2024-10-29'];
        const dayNames = ['Vendredi 25 octobre', 'Samedi 26 octobre', 'Dimanche 27 octobre', 'Lundi 28 octobre', 'Mardi 29 octobre'];
        
        // Ajouter les heures disponibles
        const hours = ['00:00', '00:30', '01:00', '01:30', '02:00', '02:30', '03:00', '03:30', 
                    '04:00', '04:30', '05:00', '05:30', '06:00', '06:30', '07:00', '07:30',
                    '08:00', '08:30', '09:00', '09:30', '10:00', '10:30', '11:00', '11:30',
                    '12:00', '12:30', '13:00', '13:30', '14:00', '14:30', '15:00', '15:30',
                    '16:00', '16:30', '17:00', '17:30', '18:00', '18:30', '19:00', '19:30',
                    '20:00', '20:30', '21:00', '21:30', '22:00', '22:30', '23:00', '23:30'];
        
        // Ajouter les options de jour
        for (let i = 0; i < dates.length; i++) {
            const startOption = document.createElement('option');
            startOption.value = dates[i];
            startOption.text = dayNames[i];
            startDaySelect.appendChild(startOption);
            
            const endOption = document.createElement('option');
            endOption.value = dates[i];
            endOption.text = dayNames[i];
            endDaySelect.appendChild(endOption);
        }
        
        // Ajouter les options d'heure
        hours.forEach(hour => {
            const startHourOption = document.createElement('option');
            startHourOption.value = hour;
            startHourOption.text = hour.replace(':', 'h');
            startHourSelect.appendChild(startHourOption);
            
            const endHourOption = document.createElement('option');
            endHourOption.value = hour;
            endHourOption.text = hour.replace(':', 'h');
            endHourSelect.appendChild(endHourOption);
        });
        
        // Valeurs par défaut
        startDaySelect.value = dates[0];  // Premier jour (25 octobre)
        endDaySelect.value = dates[dates.length-1];  // Dernier jour (29 octobre)
        startHourSelect.value = '00:00';
        endHourSelect.value = '23:30';
    }


    function loadHistoryImg(id, isUpdate = false) {
        // Récupérer les valeurs sélectionnées
        const startDay = document.getElementById(`startDay-${id}`).value;
        const startHour = document.getElementById(`startHour-${id}`).value;
        const endDay = document.getElementById(`endDay-${id}`).value;
        const endHour = document.getElementById(`endHour-${id}`).value;
        
        // Format exact attendu par le serveur: "YYYY-MM-DD HH:MM:SS"
        const startDate = `${startDay} ${startHour}:00`;
        const endDate = `${endDay} ${endHour}:00`;
        
        console.log(`Envoi dates au serveur: ${startDate} au ${endDate}`);
        
        // Récupérer les textes affichés pour l'utilisateur
        const startDaySelect = document.getElementById(`startDay-${id}`);
        const endDaySelect = document.getElementById(`endDay-${id}`);
        const startHourSelect = document.getElementById(`startHour-${id}`);
        const endHourSelect = document.getElementById(`endHour-${id}`);
        
        const startDayText = startDaySelect.options[startDaySelect.selectedIndex].text;
        const endDayText = endDaySelect.options[endDaySelect.selectedIndex].text;
        const startHourText = startHourSelect.options[startHourSelect.selectedIndex].text;
        const endHourText = endHourSelect.options[endHourSelect.selectedIndex].text;
        
        if (!isUpdate) {
            // Appliquer les préférences sauvegardées
            const prefs = loadGraphPreferences();
            document.getElementById('show-total').checked = prefs.showTotal;
            document.getElementById('show-stands').checked = prefs.showStands;
            document.getElementById('show-mechanical').checked = prefs.showMechanical;
            document.getElementById('show-electric').checked = prefs.showElectric;
        }

        // Paramètres pour le graphique
        const params = new URLSearchParams({
            start: startDate,
            end: endDate,
            show_total: document.getElementById('show-total').checked ? '1' : '0',
            show_stands: document.getElementById('show-stands').checked ? '1' : '0',
            show_mechanical: document.getElementById('show-mechanical').checked ? '1' : '0',
            show_electric: document.getElementById('show-electric').checked ? '1' : '0'
        });
        
        const imgUrl = `/history_png/${id}?${params.toString()}`;
        const station = findStationById(id);
        if (!station) return;

        // Mettre à jour le panneau avec les textes exacts des options sélectionnées
        document.getElementById('graph-station-info').textContent = station.nom;
        document.getElementById('graph-date-info').innerHTML = `
            <p class="date-range">
                Du <span class="date-value">${startDayText} à ${startHourText}</span><br>
                au <span class="date-value">${endDayText} à ${endHourText}</span>
            </p>
        `;
        
        document.getElementById('graph-panel').dataset.stationId = id;
        
        // Charger l'image
        const container = document.querySelector('.graph-image-container');
        container.innerHTML = '<div class="loading">Chargement du graphique...</div>';
        
        const img = new Image();
        img.onload = () => {
            container.innerHTML = '';
            container.appendChild(img);
        };
        img.onerror = () => {
            container.innerHTML = '<div class="error">Erreur lors du chargement du graphique</div>';
        };
        img.src = imgUrl;
        img.id = 'graph-image';
        img.alt = 'Graphique d\'occupation';
        img.style.width = '100%';
        
        if (!isUpdate) {
            document.getElementById('graph-panel').classList.add('active');
        }
    }



    function findStationById(id) {
        // Chercher dans les sources de données possibles
        return window.stations.find(s => s.idstation == id) || 
               (window.stationMarkers.find(m => m.data.idstation == id) || {}).data || null;
    }

    // Gestion des préférences
    function saveGraphPreferences() {
        const preferences = {
            showTotal: document.getElementById('show-total').checked,
            showStands: document.getElementById('show-stands').checked,
            showMechanical: document.getElementById('show-mechanical').checked,
            showElectric: document.getElementById('show-electric').checked
        };
        
        localStorage.setItem('graphPreferences', JSON.stringify(preferences));
    }

    function loadGraphPreferences() {
        const savedPrefs = localStorage.getItem('graphPreferences');
        
        if (!savedPrefs) {
            return {
                showTotal: true,
                showStands: true,
                showMechanical: true,
                showElectric: true
            };
        }
        
        return JSON.parse(savedPrefs);
    }

    // Fonction pour réinitialiser complètement l'itinéraire
    function resetRoute() {
        // Supprimer les marqueurs de départ et d'arrivée
        if (startMarker) {
            map.removeLayer(startMarker);
            startMarker = null;
        }
        
        if (endMarker) {
            map.removeLayer(endMarker);
            endMarker = null;
        }
        
        // Vider les champs d'adresse
        document.getElementById('start-address').value = '';
        document.getElementById('end-address').value = '';
        
        // Supprimer les attributs de coordonnées
        const startInput = document.getElementById('start-address');
        const endInput = document.getElementById('end-address');
        
        startInput.removeAttribute('data-has-exact-coordinates');
        startInput.removeAttribute('data-exact-lat');
        startInput.removeAttribute('data-exact-lng');
        
        endInput.removeAttribute('data-has-exact-coordinates');
        endInput.removeAttribute('data-exact-lat');
        endInput.removeAttribute('data-exact-lng');
        
        // Nettoyer les routes
        clearRoutes();
        
        // Réafficher toutes les stations selon le mode actuel
        showStations(currentDisplayMode);
    }    // Gestionnaires d'événements    
    function setupEventListeners() {
        // Formulaire d'itinéraire
        document.getElementById('calculate-route-button').addEventListener('click', calculateItinerary);
        document.getElementById('reset-route-button').addEventListener('click', e => {
            e.preventDefault();
            resetRoute();
        });
        document.getElementById('route-form').addEventListener('submit', e => e.preventDefault());
        
        // Sélection sur la carte
        document.getElementById('select-start-button').addEventListener('click', e => {
            e.preventDefault();
            activateSelectionMode('start');
        });
        
        document.getElementById('select-end-button').addEventListener('click', e => {
            e.preventDefault();
            activateSelectionMode('end');
        });
        
        // Panneaux
        document.getElementById('toggle-route-form').addEventListener('click', () => {
            document.getElementById('route-panel').classList.add('active');
        });
        
        document.getElementById('close-panel').addEventListener('click', () => {
            document.getElementById('route-panel').classList.remove('active');
            deactivateSelectionMode();
        });
        
        document.getElementById('close-graph-panel').addEventListener('click', () => {
            document.getElementById('graph-panel').classList.remove('active');
        });
        
        // Préférences graphiques
        document.getElementById('show-total').addEventListener('change', saveGraphPreferences);
        document.getElementById('show-stands').addEventListener('change', saveGraphPreferences);
        document.getElementById('show-mechanical').addEventListener('change', saveGraphPreferences);
        document.getElementById('show-electric').addEventListener('change', saveGraphPreferences);
        
        document.getElementById('update-graph').addEventListener('click', () => {
            const stationId = document.getElementById('graph-panel').dataset.stationId;
            saveGraphPreferences();
            if (stationId) loadHistoryImg(stationId, true);
        });
    }

    function resetMarker(type) {
        const isStart = type === 'start';
        const marker = isStart ? startMarker : endMarker;
        const inputId = isStart ? 'start-address' : 'end-address';
        const resetButtonId = isStart ? 'reset-start-button' : 'reset-end-button';
        
        if (marker) {
            map.removeLayer(marker);
            if (isStart) startMarker = null;
            else endMarker = null;
        }
        
        const input = document.getElementById(inputId);
        input.value = '';
        input.removeAttribute('data-has-exact-coordinates');
        input.removeAttribute('data-exact-lat');
        input.removeAttribute('data-exact-lng');
        
        document.getElementById(resetButtonId).style.display = 'none';
    }

    function calculateRoute() {
        // Récupérer les adresses
        const startAddress = document.getElementById('startAddress').value;
        const endAddress = document.getElementById('endAddress').value;
        
        if (!startAddress || !endAddress) {
            alert('Veuillez entrer les adresses de départ et d\'arrivée');
            return;
        }
        
        // Géocodage
        Promise.all([
            geocodeAddress(startAddress),
            geocodeAddress(endAddress)
        ])
        .then(([startCoord, endCoord]) => {
            // Nettoyer les points existants
            if (startMarker) map.removeLayer(startMarker);
            if (endMarker) map.removeLayer(endMarker);
            
            // Créer les nouveaux marqueurs
            startMarker = L.marker(startCoord, {
                draggable: true,
                icon: L.icon({
                    iconUrl: 'images/jambe.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34]
                })
            }).addTo(map)
              .on('dragend', calculateRouteFromMarkers);
              
            endMarker = L.marker(endCoord, {
                draggable: true,
                icon: L.icon({
                    iconUrl: 'images/jambe2.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34]
                })
            }).addTo(map)
              .on('dragend', calculateRouteFromMarkers);
            
            // Calculer l'itinéraire
            calculateRouteFromMarkers();
        })
        .catch(error => {
            console.error('Erreur de géocodage:', error);
            alert('Erreur lors du géocodage des adresses. Vérifiez la connexion et les adresses saisies.');
        });
    }
</script>
</html>