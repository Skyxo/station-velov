<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
    <title>Stations Vélo'v</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
    <link rel="stylesheet" href="style.css" />
    <meta charset="utf-8">
</head>

<body onload="initialize_page()">
    <header>
        <nav class="top-controls">
            <div id="filters">
                <button onclick="showStations('all')" data-tooltip="Toutes les stations disponibles">Toutes</button>
                <button onclick="showStations('electric')" data-tooltip="Stations avec vélos électriques"><img src="images/lightning.png" alt="Vélos électriques"></button>
                <button onclick="showStations('mechanical')" data-tooltip="Stations avec vélos mécaniques"><img src="images/jambe.png" alt="Vélos mécaniques"></button>
                <button onclick="showStations('empty')" data-tooltip="Stations vides"><img src="images/empty.png" alt="Stations vides" style="height:20px;"></button>
                <button onclick="showStations('closed')" data-tooltip="Stations fermées"><img src="images/closed.png" alt="Stations fermées" style="height:20px;"></button>
            </div>
            <h1>Stations Vélo'v</h1>
            <button id="toggle-route-form" class="toggle-button">
                <span class="toggle-icon">&#9776;</span> Itinéraire
            </button>
        </nav>
    </header>

    <div id="map"></div>

    <div id="route-panel" class="side-panel">
        <div class="panel-header">
            <h2>Calculer un itinéraire</h2>
            <button id="close-panel" class="close-button">&times;</button>
        </div>
        <form id="route-form">
            <!-- Modifier les div des groupes d'adresses dans le route-form -->
            <div class="form-group address-container">
                <label for="start-address">Adresse de départ</label>
                <div class="address-input-wrapper">
                    <input type="text" id="start-address" name="start" placeholder="Ex : 10 Rue de la République, Lyon" required autocomplete="off">
                    <ul id="start-suggestions" class="address-suggestions"></ul>
                </div>
                <button type="button" id="select-start-button" class="map-select-button">Sélectionner sur la carte</button>
            </div>

            <div class="form-group address-container">
                <label for="end-address">Adresse d'arrivée</label>
                <div class="address-input-wrapper">
                    <input type="text" id="end-address" name="end" placeholder="Ex : 5 Place Bellecour, Lyon" required autocomplete="off">
                    <ul id="end-suggestions" class="address-suggestions"></ul>
                </div>
                <button type="button" id="select-end-button" class="map-select-button">Sélectionner sur la carte</button>
            </div>
            <div class="form-group">
                <label for="bike-type">Type de vélo :</label>
                <select id="bike-type" name="bike-type">
                    <option value="any">Peu importe</option>
                    <option value="mechanical">Mécanique</option>
                    <option value="electric">Électrique</option>
                </select>
            </div>
            <button type="button" id="reset-route-button" class="reset-button">Réinitialiser</button>
            <button type="button" id="calculate-route-button" class="submit-button">Calculer l'itinéraire</button>
            <!-- Nouvel élément pour afficher le temps de trajet -->
            <div id="travel-time-container" class="travel-time">
                <span id="travel-time">Temps estimé: --</span>
            </div>
            <img id="velo_margot" src="images/velo1.jpg">
        </form>
    </div>

    <div id="graph-panel" class="bottom-panel">
        <div class="panel-header">
            <h2>Évolution de la station</h2>
            <button id="close-graph-panel" class="close-button">&times;</button>
        </div>
        <div class="panel-content">
            <div id="graph-station-info"></div>
            <div id="graph-date-info" class="date-info"></div>
            
            <div class="graph-image-container">
                <img id="graph-image" alt="Graphique d'occupation" style="width:100%; height:auto;">
            </div>
            
            <div class="graph-options">
                <h4>Données à afficher :</h4>
                <div class="graph-options-checkboxes">
                    <label><input type="checkbox" id="show-total" checked> Vélos totaux</label>
                    <label><input type="checkbox" id="show-stands" checked> Places libres</label>
                    <label><input type="checkbox" id="show-mechanical" checked> Vélos mécaniques</label>
                    <label><input type="checkbox" id="show-electric" checked> Vélos électriques</label>
                </div>
                <button id="update-graph" class="update-button">Mettre à jour le graphique</button>
            </div>
        </div>
    </div>
</body>

<script>
    // Variables globales
    let startMarker = null;
    let endMarker = null;
    let selectionMode = null;
    let selectionNotification = null;
    let map;
    let stations = [];
    let maxBikesCount = 0;
    let maxElectricCount = 0;
    let maxMechanicalCount = 0;
    let currentDisplayMode = 'all';
    window.routeSegments = [];
    window.stationMarkers = [];

    // Variables pour contrôler la saisie et les délais
    let typingTimer;
    const doneTypingInterval = 300; // Réduit à 300ms au lieu de 500ms
    const suggestionsCache = {}; // Cache pour éviter des appels API répétés

    // Icônes
    const redIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });

    const greenIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });

    const blueIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
    });

    // Initialisation de la page
    function initialize_page() {
        map = L.map('map').setView([45.75, 4.85], 13);
        
        L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Toujours initialiser avec 'all', quel que soit le filtre précédent
        currentDisplayMode = 'all';
        localStorage.setItem('currentFilterMode', 'all');
        
        map.on('click', handleMapClick);
        
        fetch('/center')
            .then(response => response.json())
            .then(center => map.setView([center.lat, center.lon], 14))
            .catch(err => console.error("Erreur chargement du centre:", err));
        
        loadStations();
        setupEventListeners();
    }

    // Fonction pour récupérer des suggestions d'adresses
    async function getSuggestions(query, isStart = true) {
        if (!query || query.length < 3) return []; // Ignorer les requêtes trop courtes
        
        // Vérifier si on a déjà ce résultat en cache
        const cacheKey = query.toLowerCase();
        if (suggestionsCache[cacheKey]) {
            return suggestionsCache[cacheKey];
        }
        
        try {
            // Montrer l'indicateur de chargement
            const containerId = isStart ? 'start-suggestions' : 'end-suggestions';
            const container = document.getElementById(containerId);
            container.innerHTML = '<li class="suggestion-item loading">Recherche en cours...</li>';
            container.style.display = 'block';
            
            // Utiliser l'API de géocodage pour obtenir des suggestions
            const url = 'https://nominatim.openstreetmap.org/search'
                    + '?format=json&limit=5&countrycodes=fr'
                    + '&viewbox=4.7,45.6,5.0,45.9&bounded=1'
                    + `&q=${encodeURIComponent(query)}`;
                    
            const response = await fetch(url, {
                headers: {'Accept-Language': 'fr'}
            });
            
            if (!response.ok) throw new Error(`Erreur géocodage: ${response.status}`);
            
            const data = await response.json();
            const results = data.map(item => ({
                displayName: item.display_name,
                lat: parseFloat(item.lat),
                lon: parseFloat(item.lon)
            }));
            
            // Sauvegarder en cache
            suggestionsCache[cacheKey] = results;
            return results;
        } catch (error) {
            console.error("Erreur lors de la récupération des suggestions:", error);
            return [];
        }
    }

    // Fonction pour afficher les suggestions
    function displaySuggestions(suggestions, containerId, inputId) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        
        if (suggestions.length === 0) {
            container.style.display = 'none';
            return;
        }
        
        suggestions.forEach((suggestion, index) => {
            const li = document.createElement('li');
            li.className = 'suggestion-item';
            li.textContent = suggestion.displayName;
            li.dataset.lat = suggestion.lat;
            li.dataset.lon = suggestion.lon;
            li.dataset.index = index;
            
            li.addEventListener('click', function() {
                selectSuggestion(suggestion, inputId);
                container.style.display = 'none';
            });
            
            container.appendChild(li);
        });
        
        container.style.display = 'block';
    }

    // Amélioration de la fonction de sélection
    function selectSuggestion(suggestion, inputId) {
        const inputElement = document.getElementById(inputId);
        
        // Ajout d'un petit délai pour éviter les problèmes de timing
        setTimeout(() => {
            inputElement.value = suggestion.displayName;
            
            // Stocker les coordonnées géographiques
            storeCoordinates(inputId, {
                lat: suggestion.lat,
                lng: suggestion.lon
            });

            console.log("Coordonnées obtenues:", suggestion.lat, suggestion.lon);
            
            // Force le focus sur l'input pour éviter les problèmes de blur
            inputElement.focus();
        }, 10);
    }

    // Configurer les gestionnaires d'événements pour les champs d'adresse
    function setupAddressSuggestions() {
        // Configuration pour l'adresse de départ
        setupInputWithSuggestions('start-address', 'start-suggestions');
        
        // Configuration pour l'adresse d'arrivée
        setupInputWithSuggestions('end-address', 'end-suggestions');
        
        // Fermer les suggestions si on clique ailleurs
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.address-input-wrapper')) {
                document.querySelectorAll('.address-suggestions').forEach(el => {
                    el.style.display = 'none';
                });
            }
        });

        // Gérer les clics sur la page
        document.addEventListener('click', function(e) {
            const allSuggestions = document.querySelectorAll('.address-suggestions');
            
            // Ne fermer les suggestions que si le clic est en dehors des zones de suggestions
            // ET en dehors des champs de saisie
            if (!e.target.closest('.address-input-wrapper') && 
                !e.target.closest('.address-suggestions')) {
                allSuggestions.forEach(el => {
                    el.style.display = 'none';
                });
            }
        });
    }

    function setupInputWithSuggestions(inputId, suggestionsId) {
        const inputElement = document.getElementById(inputId);
        const suggestionsContainer = document.getElementById(suggestionsId);
        
        // Événement d'entrée (lorsque l'utilisateur tape)
        inputElement.addEventListener('input', function() {
            clearTimeout(typingTimer);
            const query = this.value.trim();
            
            // Commencer à montrer les suggestions dès que possible
            if (query.length >= 2) {
                // Indiquer le chargement immédiatement
                suggestionsContainer.innerHTML = '<li class="suggestion-item loading">Recherche en cours...</li>';
                suggestionsContainer.style.display = 'block';
                
                // Attendre un peu que l'utilisateur finisse de taper
                typingTimer = setTimeout(async () => {
                    if (query.length >= 2) {
                        const isStart = inputId === 'start-address';
                        const suggestions = await getSuggestions(query, isStart);
                        displaySuggestions(suggestions, suggestionsId, inputId);
                    } else {
                        suggestionsContainer.style.display = 'none';
                    }
                }, doneTypingInterval);
            } else {
                suggestionsContainer.style.display = 'none';
            }
        });
        
        // Empêcher la fermeture quand on clique sur les suggestions
        suggestionsContainer.addEventListener('mousedown', function(e) {
            e.preventDefault(); // Empêche le blur de l'input avant le clic sur une suggestion
            e.stopPropagation(); // Arrête la propagation de l'événement
        });
        
        // Gérer la navigation au clavier dans les suggestions
        inputElement.addEventListener('keydown', function(e) {
            const suggestionsList = document.getElementById(suggestionsId);
            if (suggestionsList.style.display !== 'block') return;
            
            const items = suggestionsList.querySelectorAll('.suggestion-item:not(.loading)');
            if (items.length === 0) return;
            
            let selectedIndex = -1;
            
            // Trouver l'élément actuellement sélectionné
            items.forEach((item, index) => {
                if (item.classList.contains('selected')) {
                    selectedIndex = index;
                }
            });
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    if (selectedIndex < items.length - 1) {
                        if (selectedIndex >= 0) items[selectedIndex].classList.remove('selected');
                        items[selectedIndex + 1].classList.add('selected');
                        items[selectedIndex + 1].scrollIntoView({ block: 'nearest' });
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    if (selectedIndex > 0) {
                        items[selectedIndex].classList.remove('selected');
                        items[selectedIndex - 1].classList.add('selected');
                        items[selectedIndex - 1].scrollIntoView({ block: 'nearest' });
                    }
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    if (selectedIndex >= 0) {
                        const selected = items[selectedIndex];
                        selectSuggestion({
                            displayName: selected.textContent,
                            lat: parseFloat(selected.dataset.lat),
                            lon: parseFloat(selected.dataset.lon)
                        }, inputId);
                        suggestionsList.style.display = 'none';
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    suggestionsList.style.display = 'none';
                    break;
            }
        });
        
        // Afficher les suggestions lors du focus si texte déjà présent
        inputElement.addEventListener('focus', async function() {
            const query = this.value.trim();
            if (query.length >= 2) {
                const isStart = inputId === 'start-address';
                const suggestions = await getSuggestions(query, isStart);
                displaySuggestions(suggestions, suggestionsId, inputId);
            }
        });
    }

    // Modifier la fonction loadStations pour ajouter l'animation d'apparition des marqueurs

    function loadStations() {
        fetch('/stations_full')
            .then(response => response.json())
            .then(data => {
                stations = data;
                window.stations = data;
                
                // Calculer les maximums une seule fois
                maxBikesCount = Math.max(...data.map(s => s.bikes || 0));
                maxElectricCount = Math.max(...data.map(s => s.electricalBikes || 0));
                maxMechanicalCount = Math.max(...data.map(s => s.mechanicalBikes || 0));
                
                // Utiliser un fragment pour regrouper les opérations DOM
                const markers = [];
                
                // Créer les marqueurs sans animation d'apparition séquentielle
                data.forEach(station => {
                    const marker = L.marker([station.lat, station.lon], {
                        icon: getStationIcon(station, 'all')
                    });
                    
                    marker.stationData = station;
                    marker.stationId = station.idstation;
                    
                    // Ajout des écouteurs pour la barre de capacité
                    marker.on('mouseover', createCapacityBar);
                    marker.on('mouseout', removeCapacityBar);
                    marker.on('click', handleMarkerClick);
                    
                    markers.push({marker, data: station});
                });
            
                window.stationMarkers = markers;
            
                // Remplacer showStations('all') par:
                const savedMode = localStorage.getItem('currentFilterMode') || 'all';
                showStations(savedMode); // Utiliser le mode sauvegardé
            })
            .catch(err => console.error("Erreur chargement des stations:", err));
    }

    // Fonction séparée pour gérer le clic sur un marqueur
    function handleMarkerClick(e) {
        const icons = document.querySelectorAll('.leaflet-marker-icon');
        icons.forEach(icon => icon.classList.remove('active-popup'));
        e.target._icon?.classList.add('active-popup');
        
        const popup = buildStationPopupContent(e.target.stationData);
        e.target.unbindPopup().bindPopup(popup).openPopup();
        initRanges(e.target.stationData.idstation);
        removeCapacityBar();
    }

    // Gestion de la sélection de points sur la carte
    function activateSelectionMode(mode) {
        deactivateSelectionMode();
        selectionMode = mode;
        document.getElementById('map').classList.add('selecting-point');
        
        const message = mode === 'start' 
            ? 'Cliquez sur la carte pour sélectionner un point de départ'
            : 'Cliquez sur la carte pour sélectionner un point d\'arrivée';
        
        selectionNotification = document.createElement('div');
        selectionNotification.className = 'selection-notification';
        selectionNotification.textContent = message;
        document.body.appendChild(selectionNotification);
    }

    function deactivateSelectionMode() {
        selectionMode = null;
        document.getElementById('map').classList.remove('selecting-point');
        if (selectionNotification) {
            selectionNotification.remove();
            selectionNotification = null;
        }
    }

    function handleMapClick(e) {
        if (!selectionMode) return;
        
        const latlng = e.latlng;
        
        if (selectionMode === 'start') {
            if (startMarker) map.removeLayer(startMarker);
            
            startMarker = L.marker(latlng, {
                icon: greenIcon,
                draggable: true
            }).addTo(map);
            
              startMarker.on('dragend', function() {
                const newPos = startMarker.getLatLng();
                storeCoordinates('start-address', newPos);
                reverseGeocode(newPos, 'start-address');
            });
            
            storeCoordinates('start-address', latlng);
            reverseGeocode(latlng, 'start-address');
        } 
        else if (selectionMode === 'end') {
            if (endMarker) map.removeLayer(endMarker);
            
            endMarker = L.marker(latlng, {
                icon: redIcon,
                draggable: true
            }).addTo(map);
            
            endMarker.on('dragend', function() {
                const newPos = endMarker.getLatLng();
                storeCoordinates('end-address', newPos);
                reverseGeocode(newPos, 'end-address');
            });
            
            storeCoordinates('end-address', latlng);
            reverseGeocode(latlng, 'end-address');
        }
        
        deactivateSelectionMode();
    }    function storeCoordinates(inputId, latlng) {
        const inputElement = document.getElementById(inputId);
        inputElement.dataset.exactLat = latlng.lat;
        inputElement.dataset.exactLng = latlng.lng || latlng.lon;
        inputElement.dataset.hasExactCoordinates = "true";
    }

    // Calcul d'itinéraire
    function calculateItinerary(e) {
        if (e) e.preventDefault();
        
        const startInput = document.getElementById('start-address');
        const endInput = document.getElementById('end-address');
        const startAddress = startInput.value;
        const endAddress = endInput.value;
        
        if (!startAddress || !endAddress) {
            alert("Veuillez spécifier une adresse de départ et d'arrivée.");
            return;
        }
        
        // Si les deux points ont des coordonnées exactes (placés sur la carte)
        if (startInput.dataset.hasExactCoordinates === "true" && 
            endInput.dataset.hasExactCoordinates === "true" && 
            startMarker && endMarker) {
            calculateRouteFromMarkers();
        } else {
            // Sinon, on géocode les adresses
            clearRoutes();
            
            // Nettoyage des marqueurs existants
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }
            
            // Géocodage en parallèle des deux adresses
            Promise.all([
                geocode(startAddress),
                geocode(endAddress)
            ])
            .then(([startCoord, endCoord]) => {
                console.log("Coordonnées obtenues:", startCoord, endCoord);
                
                // Création des marqueurs
                startMarker = L.marker(startCoord, {
                    icon: greenIcon,
                    draggable: true
                }).addTo(map);
                
                endMarker = L.marker(endCoord, {
                    icon: redIcon,
                    draggable: true
                }).addTo(map);
                
                // Mise à jour des attributs des champs
                storeCoordinates('start-address', {lat: startCoord[0], lng: startCoord[1]});
                storeCoordinates('end-address', {lat: endCoord[0], lng: endCoord[1]});
                
                // Calcul de l'itinéraire avec les marqueurs créés
                calculateRouteFromMarkers();
            })
            .catch(error => {
                console.error("Erreur de géocodage:", error);
                alert("Impossible de localiser une ou les deux adresses. Veuillez vérifier votre saisie ou sélectionner les points sur la carte.");
            });
        }
        
        // S'assurer que le bouton reste visible
        document.getElementById('calculate-route-button').style.display = 'block';
    }

    function calculateRouteFromMarkers() {
        if (!startMarker || !endMarker) return;
        
        const startPos = startMarker.getLatLng();
        const endPos = endMarker.getLatLng();
        
        // Nettoyage des routes précédentes
        clearRoutes();
        
        // Stations les plus proches
        const startCoord = [startPos.lat, startPos.lng];
        const endCoord = [endPos.lat, endPos.lng];
        const stStart = findNearest(startCoord, true); // Station de départ avec vélos disponibles
        const stEnd = findNearest(endCoord, false);    // Station d'arrivée
        
        // Vérifier si la station de départ a été trouvée
        if (stStart.idstation === "none") {
            alert(stStart.nom);
            return;
        }
        
        // Calcul des itinéraires
        const router = L.Routing.osrmv1({
            serviceUrl: 'https://router.project-osrm.org/route/v1',
            profile: 'cycling',
            language: 'fr'
        });
        
        const segments = [
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(startPos.lat, startPos.lng)),
                    L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon))
                ],
                color: 'green'
            },
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon)),
                    L.Routing.waypoint(L.latLng(stEnd.lat, stEnd.lon))
                ],
                color: 'blue'
            },
            {
                waypoints: [
                    L.Routing.waypoint(L.latLng(stEnd.lat, stEnd.lon)),
                    L.Routing.waypoint(L.latLng(endPos.lat, endPos.lng))
                ],
                color: 'red'
            }
        ];
        
        // Variables pour cumuler le temps total
        let totalTimeSeconds = 0;
        let segmentsProcessed = 0;
        
        segments.forEach(({waypoints, color}) => {
            router.route(waypoints, (err, routes) => {
                if (err || !routes.length) {
                    console.error('Erreur routage', err);
                    return;
                }
                
                const route = routes[0];
                
                // Ajouter le temps de ce segment au total
                totalTimeSeconds += route.summary.totalTime;
                
                const line = L.Routing.line(route, {
                    styles: [{color, weight: 4, opacity: 0.8}]
                }).addTo(map);
                
                window.routeSegments.push(line);
                
                // Incrémente le compteur de segments traités
                segmentsProcessed++;
                
                // Si tous les segments sont traités, on affiche le temps total
                if (segmentsProcessed === segments.length) {
                    displayTravelTime(totalTimeSeconds);
                }
            });
        });
        
        // Ajuster la vue
        const bounds = L.latLngBounds([
            [startPos.lat, startPos.lng],
            [stStart.lat, stStart.lon],
            [stEnd.lat, stEnd.lon],
            [endPos.lat, endPos.lng]
        ]);
        map.fitBounds(bounds, {padding: [50, 50]});
    }


    // Fonction pour formater et afficher le temps de trajet
    function displayTravelTime(timeSeconds) {
        const timeContainer = document.getElementById('travel-time-container');
        const timeDisplay = document.getElementById('travel-time');
        
        // Convertir les secondes en minutes et heures
        const hours = Math.floor(timeSeconds / 3600);
        const minutes = Math.floor((timeSeconds % 3600) / 60);
        
        let formattedTime = 'Temps estimé: ';
        
        if (hours > 0) {
            formattedTime += `${hours} h ${minutes} min`;
        } else {
            formattedTime += `${minutes} minutes`;
        }
        
        // Afficher le temps
        timeDisplay.textContent = formattedTime;
        timeContainer.classList.add('active');
    }


    async function calculateRoute(startAddress, endAddress) {
        try {
            clearRoutes();
            
            // Géocodage en parallèle
            const [startCoord, endCoord] = await Promise.all([
                geocode(startAddress),
                geocode(endAddress)
            ]);            // Stations les plus proches
            const stStart = findNearest(startCoord, true); // Station de départ avec vélos disponibles
            const stEnd = findNearest(endCoord, false);    // Station d'arrivée

            // Vérifier si la station de départ a été trouvée
            if (stStart.idstation === "none") {
                alert(stStart.nom);
                return;
            }

            // Supprime les marqueurs de ces stations préexistants
            map.eachLayer(layer => {
                if (layer instanceof L.Marker && (layer.stationId === stStart.idstation || layer.stationId === stEnd.idstation)) {
                    map.removeLayer(layer);
                }
            });
            
            // Ajoute les nouveaux marqueurs bleu avec popup buildée
            [ {info: stStart, label: 'Station de départ'}, {info: stEnd, label: 'Station d\'arrivée'} ].forEach(({info, label}) => {
                const m = L.marker([info.lat, info.lon], { icon: blueIcon }).addTo(map);
                m.stationId = info.idstation; // Stocker l'ID pour pouvoir retrouver ce marqueur plus tard
                fetch('/station/' + info.idstation)
                    .then(res => res.json())
                    .then(station => m.bindPopup(buildStationPopupContent(station, label)).openPopup())
                    .catch(err => console.error(err));
            });
            
            // Calcul des itinéraires
            const router = L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'cycling',
                language: 'fr'
            });
            
            const segments = [
                {
                    waypoints: [
                        L.Routing.waypoint(L.latLng(startCoord)),
                        L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon))
                    ],
                    color: 'green'
                },
                {
                    waypoints: [
                        L.Routing.waypoint(L.latLng(stStart.lat, stStart.lon)),
                        L.Routing.waypoint(L.latLng(stEnd.lat, stEnd.lon))
                    ],
                    color: 'blue'
                },
                {
                    waypoints: [
                        L.Routing.waypoint(L.latLng(stEnd.lat, stEnd.lon)),
                        L.Routing.waypoint(L.latLng(endCoord))
                    ],
                    color: 'red'
                }
            ];
            
            segments.forEach(({waypoints, color}) => {
                router.route(waypoints, (err, routes) => {
                    if (err || !routes.length) return console.error('Erreur routage', err);
                    
                    const line = L.Routing.line(routes[0], {
                        styles: [{color, weight: 4, opacity: 0.8}]
                    }).addTo(map);
                    
                    window.routeSegments.push(line);
                });
            });
            
            // Ajuster la vue
            const bounds = L.latLngBounds([
                startCoord,
                [stStart.lat, stStart.lon],
                [stEnd.lat, stEnd.lon],
                endCoord
            ]);
            map.fitBounds(bounds, {padding: [50, 50]});
        } catch (error) {
            alert(error.message || "Erreur lors du calcul de l'itinéraire");
            console.error("Erreur:", error);
        }
    }

    function clearRoutes() {
        // Supprimer les tracés existants
        if (window.routingControl) {
            map.removeControl(window.routingControl);
            window.routingControl = null;
        }
        
        window.routeSegments.forEach(line => map.removeLayer(line));
        window.routeSegments.length = 0;
        
        // Supprimer les marqueurs d'itinéraire (sauf start/end)
        map.eachLayer(layer => {
            if (layer instanceof L.Marker && layer !== startMarker && layer !== endMarker) {
                if (layer._icon && layer._icon.src && 
                   (layer._icon.src.includes('red.png') || 
                    layer._icon.src.includes('green.png') || 
                    layer._icon.src.includes('blue.png'))) {
                    map.removeLayer(layer);
                }
            }
        });
    }

    // Géocodage et recherche de proximité
    async function reverseGeocode(latlng, inputId) {
        try {
            const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&addressdetails=1&zoom=18`;
            const response = await fetch(url, {
                headers: {'Accept-Language': 'fr'}
            });
            
            if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
            
            const data = await response.json();
            
            let address = '';
            const addr = data.address;
            
            if (addr.house_number) address += addr.house_number + ', ';
            if (addr.road) address += addr.road;
            if (addr.city || addr.town || addr.village) {
                address += ' - ' + (addr.city || addr.town || addr.village);
            }
            
            if (!address) address = data.display_name;
            
            document.getElementById(inputId).value = address;
        } catch (error) {
            console.error('Erreur géocodage inverse:', error);
        }
    }    
    
    async function geocode(address) {
        try {
            // Vérifier si on a des coordonnées exactes pour cette adresse
            const inputElement = document.querySelector(`input[value="${address}"]`) || 
                                (document.getElementById('start-address').value === address ? document.getElementById('start-address') : 
                                 document.getElementById('end-address').value === address ? document.getElementById('end-address') : null);
            
            if (inputElement && inputElement.dataset.hasExactCoordinates === "true") {
                return [parseFloat(inputElement.dataset.exactLat), parseFloat(inputElement.dataset.exactLng)];
            }
            
            if (inputElement && inputElement.dataset.lat && inputElement.dataset.lon) {
                return [parseFloat(inputElement.dataset.lat), parseFloat(inputElement.dataset.lon)];
            }

            // Vérifier si l'entrée est des coordonnées GPS (formats acceptés: "45.75, 4.85" ou "45.75 4.85")
            const gpsRegex = /^(-?\d+(\.\d+)?)\s*[,\s]\s*(-?\d+(\.\d+)?)$/;
            const gpsMatch = address.match(gpsRegex);
            
            if (gpsMatch) {
                const lat = parseFloat(gpsMatch[1]);
                const lon = parseFloat(gpsMatch[3]);
                
                // Vérifier que les coordonnées sont valides
                if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                    console.log(`Coordonnées GPS détectées: ${lat}, ${lon}`);
                    return [lat, lon];
                }
            }
            
            // Géocodage via API
            const url = 'https://nominatim.openstreetmap.org/search'
                    + '?format=json&limit=1&countrycodes=fr'
                    + '&viewbox=4.7,45.6,5.0,45.9&bounded=1'
                    + `&q=${encodeURIComponent(address)}`;
                    
            const res = await fetch(url, {
                headers: {'Accept-Language': 'fr'}
            });
            
            if (!res.ok) throw new Error(`Erreur géocodage: ${res.status}`);
            
            const data = await res.json();
            if (!data.length) throw new Error(`Adresse non trouvée: "${address}"`);
            
            return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        } catch (error) {
            throw new Error(`Impossible de localiser: "${address}"`);
        }
    }

    function haversine([lat1, lon1], [lat2, lon2]) {
        const R = 6371e3; // mètres
        const phi1 = lat1 * Math.PI/180;
        const phi2 = lat2 * Math.PI/180;
        const deltaPhi = (lat2-lat1) * Math.PI/180;
        const deltaLanda = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(deltaPhi/2)**2 + Math.cos(phi1)*Math.cos(phi2)*Math.sin(deltaLanda/2)**2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }    function findNearest(coord, isStartStation = false) {
        if (!stations || stations.length === 0) {
            return {idstation: "none", nom: "Aucune station disponible", lat: coord[0], lon: coord[1]};
        }
        
        let minDist = Infinity;
        let nearest = null;
        
        // Pour la station de départ, on doit vérifier la disponibilité des vélos
        const bikeType = document.getElementById('bike-type').value;
        
        for (const s of stations) {
            if (!s.lat || !s.lon) continue;
            
            // Si c'est la station de départ, vérifier la disponibilité des vélos selon le type
            if (isStartStation) {
                // Station fermée, on passe
                if (s.status !== 'OPEN') continue;
                
                // Vérifier si la station a des vélos du type demandé
                if (bikeType === 'electric' && (!s.electricalBikes || s.electricalBikes <= 0)) continue;
                if (bikeType === 'mechanical' && (!s.mechanicalBikes || s.mechanicalBikes <= 0)) continue;
                if (bikeType === 'any' && (!s.bikes || s.bikes <= 0)) continue;
            }
            
            const d = haversine(coord, [s.lat, s.lon]);
            if (d < minDist) {
                minDist = d;
                nearest = s;
            }
        }
        
        if (!nearest) {
            if (isStartStation) {
                let errorMsg = "Aucune station disponible avec ";
                if (bikeType === 'electric') errorMsg += "des vélos électriques";
                else if (bikeType === 'mechanical') errorMsg += "des vélos mécaniques";
                else errorMsg += "des vélos";
                errorMsg += " à proximité";
                
                return {idstation: "none", nom: errorMsg, lat: coord[0], lon: coord[1]};
            } else {
                return {idstation: "none", nom: "Aucune station à proximité", lat: coord[0], lon: coord[1]};
            }
        }
        
        return nearest;
    }


    function getStationIcon(station, mode) {
        const isClosed = station.status !== 'OPEN';
        const electricCount = station.electricalBikes || 0;
        const mechanicalCount = station.mechanicalBikes || 0;
        const totalBikes = electricCount + mechanicalCount;
        const isEmpty = totalBikes === 0;
        
        // Taille de l'icône basée sur le nombre de vélos - Augmentation de la différence entre min et max
        const minSize = 25, maxSize = 65;
        let size = minSize;
        
        if (mode === 'all' && !isEmpty && !isClosed) {
            // Utilisation d'une fonction non-linéaire pour accentuer la différence
            const ratio = Math.pow(totalBikes / maxBikesCount, 0.7); // Exposant <1 donne plus de contraste
            size = minSize + (maxSize - minSize) * ratio;
        } else if (mode === 'electric' && electricCount > 0 && !isClosed) {
            const ratio = Math.pow(electricCount / maxElectricCount, 0.7);
            size = minSize + (maxSize - minSize) * ratio;
        } else if (mode === 'mechanical' && mechanicalCount > 0 && !isClosed) {
            const ratio = Math.pow(mechanicalCount / maxMechanicalCount, 0.7);
            size = minSize + (maxSize - minSize) * ratio;
        }
        
        let iconUrl;
        
        // Choisir l'icône selon le type de station
        if (isClosed) {
            iconUrl = 'images/marker-icon_v_closed.png';
        } else if (isEmpty) {
            iconUrl = 'images/marker-icon_v_empty.png';
        } else if (mode === 'electric' && electricCount > 0) {
            iconUrl = 'images/marker-icon_v_elec.png';
        } else if (mode === 'mechanical' && mechanicalCount > 0) {
            iconUrl = 'images/marker-icon_v_meca.png';
        } else if (electricCount > 0 && mechanicalCount > 0) {
            // Icône mixte pour stations avec les deux types de vélos
            return createMixedIcon(station, size, electricCount / totalBikes);
        } else if (electricCount > 0) {
            iconUrl = 'images/marker-icon_v_elec.png';
        } else {
            iconUrl = 'images/marker-icon_v_meca.png';
        }
        
        return L.icon({
            iconUrl: iconUrl,
            iconSize: [size, size],
            iconAnchor: [size/2, size],
            popupAnchor: [0, -size]
        });
    }


    function createMixedIcon(station, size, electricRatio) {
        const container = document.createElement('div');
        container.className = 'proportional-marker-container';
        container.style.width = `${size}px`;
        container.style.height = `${size}px`;
        container.style.position = 'relative';
        container.style.overflow = 'hidden';
        // Retrait de borderRadius, boxShadow et border qui créaient l'effet de bulle
        
        // Élément pour vélos mécaniques (arrière-plan)
        const mechDiv = document.createElement('div');
        mechDiv.style.position = 'absolute';
        mechDiv.style.top = '0';
        mechDiv.style.left = '0';
        mechDiv.style.width = `${size}px`;
        mechDiv.style.height = `${size}px`;
        mechDiv.style.backgroundImage = 'url(images/marker-icon_v_meca.png)';
        mechDiv.style.backgroundSize = 'cover';
        mechDiv.style.filter = 'saturate(1.4) contrast(1.1)'; // Renforce la saturation et le contraste
        
        // Calcule largeur exacte pour éviter les problèmes d'arrondi
        const elecWidth = Math.max(Math.round(size * electricRatio), 5); // Au moins 5px pour être visible
        
        // Élément pour vélos électriques (partie proportionnelle)
        const elecDiv = document.createElement('div');
        elecDiv.style.position = 'absolute';
        elecDiv.style.top = '0';
        elecDiv.style.left = '0';
        elecDiv.style.width = elecWidth + 'px';
        elecDiv.style.height = `${size}px`;
        elecDiv.style.backgroundImage = 'url(images/marker-icon_v_elec.png)';
        elecDiv.style.backgroundSize = `${size}px ${size}px`; // Assure que l'image est à la bonne taille
        elecDiv.style.filter = 'saturate(1.5) contrast(1.2)'; // Renforce davantage la saturation/contraste
        // Retrait de la ligne de séparation
        
        container.appendChild(mechDiv);
        container.appendChild(elecDiv);
        
        return L.divIcon({
            html: container,
            className: 'custom-div-icon',
            iconSize: [size, size],
            iconAnchor: [size/2, size],
            popupAnchor: [0, -size]
        });
    }


    function showStations(mode) {
        currentDisplayMode = mode;
        
        // Sauvegarder le mode actuel
        localStorage.setItem('currentFilterMode', mode);

        // Appliquer les couleurs correspondant au mode
        setFilterColors(mode);
        
        // Supprimer tous les marqueurs existants
        map.eachLayer(function(layer) {
            if (layer instanceof L.Marker && layer !== startMarker && layer !== endMarker) {
                map.removeLayer(layer);
            }
        });
        
        // Afficher les marqueurs selon le mode
        window.stationMarkers.forEach(({marker, data}) => {
            const electricCount = data.electricalBikes || 0;
            const mechanicalCount = data.mechanicalBikes || 0;
            const totalBikes = electricCount + mechanicalCount;
            const isEmpty = totalBikes === 0;
            const isClosed = data.status !== 'OPEN';
            
            let shouldShow = true;
            
            switch(mode) {
                case 'empty': shouldShow = isEmpty && !isClosed; break;
                case 'closed': shouldShow = isClosed; break;
                case 'electric': shouldShow = (electricCount > 0 || isEmpty) && !isClosed; break;
                case 'mechanical': shouldShow = (mechanicalCount > 0 || isEmpty) && !isClosed; break;
            }
            
            if (shouldShow) {
                marker.setIcon(getStationIcon(data, mode));
                marker.addTo(map);
            }
        });
    }
    

    // Affichage des popups et graphiques
    function buildStationPopupContent(station, label = station.nom) {
        let content = '<div class="station-popup">';
        
        content += '<h3>' + label + '</h3>';
        content += '<div class="address">' + formatAddress(station) + '</div>';

        // Nouvelle grille d'informations
        content += '<div class="info-grid">';
        
        // Statut
        const statusClass = station.status === 'OPEN' ? 'status-open' : 'status-closed';
        const statusText = station.status === 'OPEN' ? 'Ouverte' : 'Fermée';
        content += `<div class="info-cell"><span class="label">Statut: </span><span class="value ${statusClass}">${statusText}</span></div>`;
        
        // Capacité
        content += `<div class="info-cell"><span class="label">Capacité: </span><span class="value">${station.capacity || 0}</span></div>`;
        
        // Places libres
        content += `<div class="info-cell"><span class="label">Places libres: </span><span class="value">${station.stands || 0}</span></div>`;
        
        // Vélos disponibles
        content += `<div class="info-cell"><span class="label">Vélos disponibles: </span><span class="value">${station.bikes || 0}</span></div>`;
        
        content += '</div>';

        // Vélos par type
        content += '<div class="bikes-available">';
        content += `<div class="bike-type electric"><div class="bike-count">${station.electricalBikes || 0}</div><div>Électriques</div></div>`;
        content += `<div class="bike-type mechanical"><div class="bike-count">${station.mechanicalBikes || 0}</div><div>Mécaniques</div></div>`;
        content += '</div>';

        // Dernière mise à jour
        content += `<div class="last-update">Mise à jour: ${formatDate(station.horodate || '')}</div>`;

        // Section de sélection de date
        content += `<div class="date-selector">
            <div class="date-group">
                <label>Du:</label>
                <select id="startDay-${station.idstation}" class="date-select"></select>
                <select id="startHour-${station.idstation}" class="time-select"></select>
            </div>
            <div class="date-group">
                <label>Au:</label>
                <select id="endDay-${station.idstation}" class="date-select"></select>
                <select id="endHour-${station.idstation}" class="time-select"></select>
            </div>
            <button class="graph-button" onclick="loadHistoryImg(${station.idstation})">
                Afficher l'historique
            </button>
        </div>`;

        content += '</div>';
        return content;
    }

    // Fonction pour créer et afficher la barre de charge au survol
    function createCapacityBar(e) {
        // Ne créer la barre que si le mode actuel est 'all'
        if (currentDisplayMode !== 'all') return;
        
        // Suppression des anciennes barres potentiellement présentes
        removeCapacityBar();
        
        const station = e.target.stationData;
        if (!station) return;
        
        // Récupération des données
        const electricCount = station.electricalBikes || 0;
        const mechanicalCount = station.mechanicalBikes || 0;
        const emptySpots = station.stands || 0;
        const totalBikes = electricCount + mechanicalCount;
        const capacity = station.capacity || (electricCount + mechanicalCount + emptySpots);
        
        // Créer un conteneur commun
        const barContainer = document.createElement('div');
        
        // Cas 1: Station fermée
        if (station.status !== 'OPEN') {
            barContainer.className = 'station-capacity-bar closed-station-message';
            barContainer.textContent = 'Station fermée';
            
            document.body.appendChild(barContainer);
            
            // Positionnement sous le marqueur
            const markerPos = e.target._icon.getBoundingClientRect();
            barContainer.style.bottom = `${window.innerHeight - markerPos.top + 10}px`;
            barContainer.style.left = `${markerPos.left + markerPos.width/2}px`;
            
            return;
        }
        
        // Cas 2: Station sans vélos
        if (totalBikes === 0 && emptySpots > 0) {
            barContainer.className = 'station-capacity-bar empty-station-message';
            barContainer.textContent = `${emptySpots} places disponibles`;
            
            document.body.appendChild(barContainer);
            
            // Positionnement sous le marqueur
            const markerPos = e.target._icon.getBoundingClientRect();
            barContainer.style.bottom = `${window.innerHeight - markerPos.top + 10}px`;
            barContainer.style.left = `${markerPos.left + markerPos.width/2}px`;
            
            return;
        }
        
        // Cas 3: Station normale avec vélos
        barContainer.className = 'station-capacity-bar';
        
        // Calcul des pourcentages pour chaque segment
        const electricPercent = (electricCount / capacity) * 100;
        const mechanicalPercent = (mechanicalCount / capacity) * 100;
        const emptyPercent = (emptySpots / capacity) * 100;
        
        // Le reste du code pour la barre de capacité standard...
        // (Création des segments, etc.)
        
        // Création des segments
        if (electricCount > 0) {
            const electric = document.createElement('div');
            electric.className = 'capacity-segment electric-bikes';
            electric.style.width = `${electricPercent}%`;
            electric.title = `${electricCount} vélos électriques`;
            barContainer.appendChild(electric);
        }
        
        if (mechanicalCount > 0) {
            const mechanical = document.createElement('div');
            mechanical.className = 'capacity-segment mechanical-bikes';
            mechanical.style.width = `${mechanicalPercent}%`;
            mechanical.title = `${mechanicalCount} vélos mécaniques`;
            barContainer.appendChild(mechanical);
        }
        
        if (emptySpots > 0) {
            const empty = document.createElement('div');
            empty.className = 'capacity-segment empty-spots';
            empty.style.width = `${emptyPercent}%`;
            empty.title = `${emptySpots} places libres`;
            barContainer.appendChild(empty);
        }
        
        // Ajout à la page
        document.body.appendChild(barContainer);
        
        // Positionnement de la barre sous le marqueur
        const markerPos = e.target._icon.getBoundingClientRect();
        barContainer.style.left = `${markerPos.left + markerPos.width/2}px`;
        barContainer.style.bottom = `${window.innerHeight - markerPos.top + 10}px`;
    }


    // Fonction pour supprimer la barre de capacité
    function removeCapacityBar() {
        const bars = document.querySelectorAll('.station-capacity-bar');
        bars.forEach(bar => bar.remove());
    }


    function formatAddress(station) {
        let address = station.adresse1 || '';
        if (station.adresse2 && station.adresse2.trim() !== '') {
            address += ', ' + station.adresse2;
        }
        if (station.commune) {
            address += ' - ' + station.commune;
        }
        return address;
    }

    function formatDate(dateStr) {
        if (!dateStr) return 'Non disponible';
        try {
            const date = new Date(dateStr);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        } catch (e) {
            return dateStr;
        }
    }

    function initRanges(id) {
        const startDaySelect = document.getElementById(`startDay-${id}`);
        const endDaySelect = document.getElementById(`endDay-${id}`);
        const startHourSelect = document.getElementById(`startHour-${id}`);
        const endHourSelect = document.getElementById(`endHour-${id}`);
        
        // Vider les sélecteurs existants
        while (startDaySelect.firstChild) startDaySelect.removeChild(startDaySelect.firstChild);
        while (endDaySelect.firstChild) endDaySelect.removeChild(endDaySelect.firstChild);
        while (startHourSelect.firstChild) startHourSelect.removeChild(startHourSelect.firstChild);
        while (endHourSelect.firstChild) endHourSelect.removeChild(endHourSelect.firstChild);
        
        // Ajouter les dates disponibles (25-29 octobre au lieu de 24-28)
        const dates = ['2024-10-25', '2024-10-26', '2024-10-27', '2024-10-28', '2024-10-29'];
        const dayNames = ['Vendredi 25 octobre', 'Samedi 26 octobre', 'Dimanche 27 octobre', 'Lundi 28 octobre', 'Mardi 29 octobre'];
        
        // Ajouter les heures disponibles
        const hours = ['00:00', '00:30', '01:00', '01:30', '02:00', '02:30', '03:00', '03:30', 
                    '04:00', '04:30', '05:00', '05:30', '06:00', '06:30', '07:00', '07:30',
                    '08:00', '08:30', '09:00', '09:30', '10:00', '10:30', '11:00', '11:30',
                    '12:00', '12:30', '13:00', '13:30', '14:00', '14:30', '15:00', '15:30',
                    '16:00', '16:30', '17:00', '17:30', '18:00', '18:30', '19:00', '19:30',
                    '20:00', '20:30', '21:00', '21:30', '22:00', '22:30', '23:00', '23:30'];
        
        // Ajouter les options de jour
        for (let i = 0; i < dates.length; i++) {
            const startOption = document.createElement('option');
            startOption.value = dates[i];
            startOption.text = dayNames[i];
            startDaySelect.appendChild(startOption);
            
            const endOption = document.createElement('option');
            endOption.value = dates[i];
            endOption.text = dayNames[i];
            endDaySelect.appendChild(endOption);
        }
        
        // Ajouter les options d'heure
        hours.forEach(hour => {
            const startHourOption = document.createElement('option');
            startHourOption.value = hour;
            startHourOption.text = hour.replace(':', 'h');
            startHourSelect.appendChild(startHourOption);
            
            const endHourOption = document.createElement('option');
            endHourOption.value = hour;
            endHourOption.text = hour.replace(':', 'h');
            endHourSelect.appendChild(endHourOption);
        });
        
        // Valeurs par défaut
        startDaySelect.value = dates[0];  // Premier jour (25 octobre)
        endDaySelect.value = dates[dates.length-1];  // Dernier jour (29 octobre)
        startHourSelect.value = '00:00';
        endHourSelect.value = '23:30';
    }


    function loadHistoryImg(id, isUpdate = false) {
        // Récupérer les valeurs sélectionnées
        const startDay = document.getElementById(`startDay-${id}`).value;
        const startHour = document.getElementById(`startHour-${id}`).value;
        const endDay = document.getElementById(`endDay-${id}`).value;
        const endHour = document.getElementById(`endHour-${id}`).value;
        
        // Format exact attendu par le serveur: "YYYY-MM-DD HH:MM:SS"
        const startDate = `${startDay} ${startHour}:00`;
        const endDate = `${endDay} ${endHour}:00`;
        
        console.log(`Envoi dates au serveur: ${startDate} au ${endDate}`);
        
        // Récupérer les textes affichés pour l'utilisateur
        const startDaySelect = document.getElementById(`startDay-${id}`);
        const endDaySelect = document.getElementById(`endDay-${id}`);
        const startHourSelect = document.getElementById(`startHour-${id}`);
        const endHourSelect = document.getElementById(`endHour-${id}`);
        
        const startDayText = startDaySelect.options[startDaySelect.selectedIndex].text;
        const endDayText = endDaySelect.options[endDaySelect.selectedIndex].text;
        const startHourText = startHourSelect.options[startHourSelect.selectedIndex].text;
        const endHourText = endHourSelect.options[endHourSelect.selectedIndex].text;
        
        if (!isUpdate) {
            // Appliquer les préférences sauvegardées
            const prefs = loadGraphPreferences();
            document.getElementById('show-total').checked = prefs.showTotal;
            document.getElementById('show-stands').checked = prefs.showStands;
            document.getElementById('show-mechanical').checked = prefs.showMechanical;
            document.getElementById('show-electric').checked = prefs.showElectric;
        }

        // Paramètres pour le graphique
        const params = new URLSearchParams({
            start: startDate,
            end: endDate,
            show_total: document.getElementById('show-total').checked ? '1' : '0',
            show_stands: document.getElementById('show-stands').checked ? '1' : '0',
            show_mechanical: document.getElementById('show-mechanical').checked ? '1' : '0',
            show_electric: document.getElementById('show-electric').checked ? '1' : '0'
        });
        
        const imgUrl = `/history_png/${id}?${params.toString()}`;
        const station = findStationById(id);
        if (!station) return;

        // Mettre à jour le panneau avec les textes exacts des options sélectionnées
        document.getElementById('graph-station-info').textContent = station.nom;
        document.getElementById('graph-date-info').innerHTML = `
            <p class="date-range">
                Du <span class="date-value">${startDayText} à ${startHourText}</span><br>
                au <span class="date-value">${endDayText} à ${endHourText}</span>
            </p>
        `;
        
        document.getElementById('graph-panel').dataset.stationId = id;
        
        // Charger l'image
        const container = document.querySelector('.graph-image-container');
        container.innerHTML = '<div class="loading">Chargement du graphique...</div>';
        
        const img = new Image();
        img.onload = () => {
            container.innerHTML = '';
            container.appendChild(img);
        };
        img.onerror = () => {
            container.innerHTML = '<div class="error">Erreur lors du chargement du graphique</div>';
        };
        img.src = imgUrl;
        img.id = 'graph-image';
        img.alt = 'Graphique d\'occupation';
        img.style.width = '100%';
        
        if (!isUpdate) {
            document.getElementById('graph-panel').classList.add('active');
        }
    }



    function findStationById(id) {
        // Chercher dans les sources de données possibles
        return window.stations.find(s => s.idstation == id) || 
               (window.stationMarkers.find(m => m.data.idstation == id) || {}).data || null;
    }

    // Gestion des préférences
    function saveGraphPreferences() {
        const preferences = {
            showTotal: document.getElementById('show-total').checked,
            showStands: document.getElementById('show-stands').checked,
            showMechanical: document.getElementById('show-mechanical').checked,
            showElectric: document.getElementById('show-electric').checked
        };
        
        localStorage.setItem('graphPreferences', JSON.stringify(preferences));
    }

    function loadGraphPreferences() {
        const savedPrefs = localStorage.getItem('graphPreferences');
        
        if (!savedPrefs) {
            return {
                showTotal: true,
                showStands: true,
                showMechanical: true,
                showElectric: true
            };
        }
        
        return JSON.parse(savedPrefs);
    }

    // Fonction pour réinitialiser complètement l'itinéraire
    function resetRoute() {
        // Supprimer les marqueurs de départ et d'arrivée
        if (startMarker) {
            map.removeLayer(startMarker);
            startMarker = null;
        }
        
        if (endMarker) {
            map.removeLayer(endMarker);
            endMarker = null;
        }
        
        // Vider les champs d'adresse
        document.getElementById('start-address').value = '';
        document.getElementById('end-address').value = '';
        
        // Supprimer les attributs de coordonnées
        const startInput = document.getElementById('start-address');
        const endInput = document.getElementById('end-address');
        
        startInput.removeAttribute('data-has-exact-coordinates');
        startInput.removeAttribute('data-exact-lat');
        startInput.removeAttribute('data-exact-lng');
        
        endInput.removeAttribute('data-has-exact-coordinates');
        endInput.removeAttribute('data-exact-lat');
        endInput.removeAttribute('data-exact-lng');
        
        // Nettoyer les routes
        clearRoutes();
        
        // Cacher le temps de trajet
        document.getElementById('travel-time-container').classList.remove('active');
        
        // Réafficher toutes les stations selon le mode actuel
        showStations(currentDisplayMode);
    }
    
    
    function setupEventListeners() {

        // Ajouter configuration des suggestions d'adresses
        setupAddressSuggestions();
        // Formulaire d'itinéraire
        document.getElementById('calculate-route-button').addEventListener('click', calculateItinerary);
        document.getElementById('reset-route-button').addEventListener('click', e => {
            e.preventDefault();
            resetRoute();
        });
        document.getElementById('route-form').addEventListener('submit', e => e.preventDefault());
        
        // Sélection sur la carte
        document.getElementById('select-start-button').addEventListener('click', e => {
            e.preventDefault();
            activateSelectionMode('start');
        });
        
        document.getElementById('select-end-button').addEventListener('click', e => {
            e.preventDefault();
            activateSelectionMode('end');
        });
        
        // Panneaux
        document.getElementById('toggle-route-form').addEventListener('click', () => {
            document.getElementById('route-panel').classList.add('active');
        });
        
        document.getElementById('close-panel').addEventListener('click', () => {
            document.getElementById('route-panel').classList.remove('active');
            deactivateSelectionMode();
        });
        
        document.getElementById('close-graph-panel').addEventListener('click', () => {
            document.getElementById('graph-panel').classList.remove('active');
        });
        
        // Préférences graphiques
        document.getElementById('show-total').addEventListener('change', saveGraphPreferences);
        document.getElementById('show-stands').addEventListener('change', saveGraphPreferences);
        document.getElementById('show-mechanical').addEventListener('change', saveGraphPreferences);
        document.getElementById('show-electric').addEventListener('change', saveGraphPreferences);
        
        document.getElementById('update-graph').addEventListener('click', () => {
            const stationId = document.getElementById('graph-panel').dataset.stationId;
            saveGraphPreferences();
            if (stationId) loadHistoryImg(stationId, true);
        });
    }

    function resetMarker(type) {
        const isStart = type === 'start';
        const marker = isStart ? startMarker : endMarker;
        const inputId = isStart ? 'start-address' : 'end-address';
        const resetButtonId = isStart ? 'reset-start-button' : 'reset-end-button';
        
        if (marker) {
            map.removeLayer(marker);
            if (isStart) startMarker = null;
            else endMarker = null;
        }
        
        const input = document.getElementById(inputId);
        input.value = '';
        input.removeAttribute('data-has-exact-coordinates');
        input.removeAttribute('data-exact-lat');
        input.removeAttribute('data-exact-lng');
        
        document.getElementById(resetButtonId).style.display = 'none';
    }

    function setFilterColors(mode) {
        // Palette de couleurs pour chaque mode
        const colors = {
            'all': '#4CAF50',         // Vert pour toutes les stations
            'electric': '#2196F3',    // Bleu pour vélos électriques
            'mechanical': '#4CAF50',  // Orange pour vélos mécaniques
            'empty': '#9E9E9E',       // Gris pour stations vides
            'closed': '#F44336'       // Rouge pour stations fermées
        };
        // Obtenir la couleur correspondante au mode
        const color = colors[mode] || colors.all;
        // header <h1>
        const h1 = document.querySelector('header h1');
        h1.style.backgroundColor = color;
        h1.parentNode.style.backgroundColor = color;
        h1.parentNode.parentNode.style.backgroundColor = color;

        // bouton "Calculer l'itinéraire"
        const submitBtn = document.querySelector('.submit-button');
        submitBtn.style.backgroundColor = color;

        // bouton "Calculer l'itinéraire"
        const mapSelecB = document.querySelector('.map-select-button');
        mapSelecB.style.backgroundColor = color;

        // bouton "Calculer l'itinéraire"
        const mapSelecEndB = document.querySelector('#select-end-button');
        mapSelecEndB.style.backgroundColor = color;

        // bouton "Calculer l'itinéraire"
        const resB = document.querySelector('.reset-button');
        resB.style.backgroundColor = color;

        // titre <h2> du panneau itinéraire
        const panelH2 = document.querySelector('.panel-header h2');
        panelH2.parentNode.style.backgroundColor = color;
        
        // NOUVELLES MODIFICATIONS:
        
        // titre "Évolution de la station" (entête du panneau graphique)
        const graphPanelHeader = document.querySelector('#graph-panel .panel-header');
        if (graphPanelHeader) graphPanelHeader.style.backgroundColor = color;
        
        // bouton "Mettre à jour le graphique"
        const updateButton = document.querySelector('.update-button');
        if (updateButton) updateButton.style.backgroundColor = color;
        
        // Mettre à jour le style CSS pour les boutons d'historique qui seront créés dans les popups
        // Ceci est nécessaire car ces boutons sont générés dynamiquement quand on clique sur une station
        document.documentElement.style.setProperty('--current-mode-color', color);
    }

</script>
</html> 